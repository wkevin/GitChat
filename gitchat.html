<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">

    <title>gitchat</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="assets/css/bootstrap.min.css" >

    <!-- Custom styles for this template -->
    <link href="assets/css/dashboard.css" rel="stylesheet">

    <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  { color: #cccccc; background-color: #303030; }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ffcfaf; } /* Alert */
code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
code span.at { } /* Attribute */
code span.bn { color: #dca3a3; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #f0dfaf; } /* ControlFlow */
code span.ch { color: #dca3a3; } /* Char */
code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
code span.co { color: #7f9f7f; } /* Comment */
code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
code span.do { color: #7f9f7f; } /* Documentation */
code span.dt { color: #dfdfbf; } /* DataType */
code span.dv { color: #dcdccc; } /* DecVal */
code span.er { color: #c3bf9f; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #c0bed1; } /* Float */
code span.fu { color: #efef8f; } /* Function */
code span.im { } /* Import */
code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
code span.kw { color: #f0dfaf; } /* Keyword */
code span.op { color: #f0efd0; } /* Operator */
code span.ot { color: #efef8f; } /* Other */
code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
code span.sc { color: #dca3a3; } /* SpecialChar */
code span.ss { color: #cc9393; } /* SpecialString */
code span.st { color: #cc9393; } /* String */
code span.va { } /* Variable */
code span.vs { color: #cc9393; } /* VerbatimString */
code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
    </style>
    <link rel="stylesheet" href="assets/css/md2html.css" />
  </head>

  <body>

    <div class="container-fluid">
      <div class="row">
        <div id="sidebar" class="col-sm-3 col-md-3 sidebar">
          <ul>
          <li><a href="#round-1-起步">Round 1 : 起步</a><ul>
          <li><a href="#git-在哪里">git 在哪里</a></li>
          <li><a href="#git-for-windows-咋用">Git for Windows 咋用</a></li>
          <li><a href="#先单机玩玩还是先弄来个别人的-git-库">先单机玩玩还是先弄来个别人的 git 库</a></li>
          <li><a href="#如何在本机-git-我的日记">如何在本机 git 我的日记</a></li>
          </ul></li>
          <li><a href="#round-2-优雅">Round 2 : 优雅</a><ul>
          <li><a href="#每次都要敲-addcommitstatus嫌累了">每次都要敲 add、commit、status，嫌累了</a></li>
          <li><a href="#有些文件不希望被-git-管理">有些文件不希望被 git 管理</a></li>
          <li><a href="#我要筛选-git-log">我要筛选 git log</a></li>
          <li><a href="#觉得-git-log-中的时间看着困难精简下呗">觉得 git log 中的时间看着困难，精简下呗</a></li>
          <li><a href="#我要定制-git-log不想一页看不了几条">我要定制 git log，不想一页看不了几条</a></li>
          <li><a href="#oneline-太简陋了一行里面看到-hashauthordatemessage">oneline 太简陋了，一行里面看到 hash、author、date、message</a></li>
          <li><a href="#git-log-已经很好了但好像还是缺点啥">git log 已经很好了，但好像还是缺点啥</a></li>
          <li><a href="#git-log-fuller-中的-author-和-commit-啥关系">git log –fuller 中的 author 和 commit 啥关系</a></li>
          <li><a href="#看-log-的时候能否把修改了哪些文件也列出来">看 log 的时候能否把修改了哪些文件也列出来</a></li>
          <li><a href="#看-tag-的时候能否把日期时间也列出来">看 tag 的时候能否把日期时间也列出来</a></li>
          <li><a href="#我要能像-tortoisesvn-那样左右两栏对比看-diff">我要能像 TortoiseSVN 那样左右两栏对比看 diff</a></li>
          <li><a href="#修改完了为什么不是直接提交而是-git-add">修改完了为什么不是直接提交，而是 git add</a></li>
          <li><a href="#我用-ubuntu我要修改-git-commit-时的默认编辑器">我用 ubuntu，我要修改 git commit 时的默认编辑器</a></li>
          </ul></li>
          <li><a href="#round-3-并发">Round 3 : 并发</a><ul>
          <li><a href="#我想使用个分支branch怎么做">我想使用个分支（branch），怎么做</a></li>
          <li><a href="#如何在分支间来回切换">如何在分支间来回切换</a></li>
          <li><a href="#删除分支总是想用-git-branch-delete">删除分支总是想用 git branch delete</a></li>
          <li><a href="#分支的合并git-merge有哪几种场景">分支的合并（git merge）有哪几种场景</a></li>
          <li><a href="#合并时如何处理分支中的垃圾log">合并时如何处理分支中的“垃圾”log</a></li>
          <li><a href="#把特性分支合入主干和把主干合入特性分支有什么区别">“把特性分支合入主干”和“把主干合入特性分支”有什么区别</a></li>
          <li><a href="#git-merge-有没有图形化的工具">git merge 有没有图形化的工具</a></li>
          <li><a href="#git-分支之间的关系能否图示">git 分支之间的关系能否图示</a></li>
          <li><a href="#分支名能否用中文">分支名能否用中文</a></li>
          <li><a href="#分支太多容易分不清咋办">分支太多容易分不清咋办</a></li>
          </ul></li>
          <li><a href="#round-4-协作">Round 4 : 协作</a><ul>
          <li><a href="#想看看别人的-git-库了">想看看别人的 git 库了</a></li>
          <li><a href="#橡树与木棉">橡树与木棉</a></li>
          <li><a href="#git-与-github">git 与 github</a></li>
          <li><a href="#github-与他的小伙伴们到哪里找开源项目">github 与他的小伙伴们（到哪里找开源项目）</a></li>
          <li><a href="#为什么-github-成了程序员的麦加圣地">为什么 github 成了程序员的麦加圣地</a></li>
          <li><a href="#公司内如何穿过-proxy-访问-github">公司内如何穿过 Proxy 访问 github</a><ul>
          <li><a href="#使用-git-config-配置">使用 git config 配置</a></li>
          <li><a href="#使用-shell-环境变量配置">使用 shell 环境变量配置</a></li>
          </ul></li>
          <li><a href="#定义了外网和内网两个-remoteproxy-怎么同时支持">定义了外网和内网两个 remote，proxy 怎么同时支持</a></li>
          <li><a href="#ssh-访问-remote-的通常步骤是啥">SSH 访问 remote 的通常步骤是啥</a></li>
          <li><a href="#如何与别人合作">如何与别人合作</a></li>
          <li><a href="#如何在-github-上与别人合作">如何在 github 上与别人合作</a></li>
          <li><a href="#怎样才能第一时间得知-git-上有提交和更新">怎样才能第一时间得知 git 上有提交和更新</a></li>
          <li><a href="#为什么说不要用-git-pull而是用-git-fetch-git-merge-代替">为什么说不要用 git pull，而是用 git fetch + git merge 代替</a></li>
          <li><a href="#如何不-clonefetch-到本地看-remote-repo-的-log">如何不 clone/fetch 到本地看 remote repo 的 log?</a></li>
          <li><a href="#程序猿如何频繁地-commit但又低调地-push">程序猿如何频繁地 commit，但又低调地 push</a></li>
          <li><a href="#通过-http-push-时每次都要求输入-namepassword能否避开">通过 http push 时每次都要求输入 name/password，能否避开</a></li>
          <li><a href="#如何删除远程分支">如何删除远程分支</a></li>
          <li><a href="#如何删除远程-tag">如何删除远程 tag</a></li>
          <li><a href="#别人把远程分支删除了我本地的对应分支怎么还在">别人把远程分支删除了，我本地的对应分支怎么还在</a></li>
          <li><a href="#维持树的整洁">维持树的整洁</a></li>
          <li><a href="#git-多用户间协作还有什么引人入胜之处">Git 多用户间协作还有什么引人入胜之处</a></li>
          </ul></li>
          <li><a href="#round-5-整理">Round 5 : 整理</a><ul>
          <li><a href="#git-从何而来">git 从何而来</a></li>
          <li><a href="#git-去往何处">git 去往何处</a></li>
          <li><a href="#git-有哪些好的入门的资料">git 有哪些好的入门的资料</a></li>
          <li><a href="#git-命令我掌握的七七八八了怎么整理一下">git 命令我掌握的七七八八了，怎么整理一下</a></li>
          <li><a href="#重新梳理-git-的软件">重新梳理 git 的软件</a></li>
          <li><a href="#整理-git-的外网托管网站">整理 git 的外网托管网站</a></li>
          <li><a href="#linux-中能否使用多个版本的-git">linux 中能否使用多个版本的 git</a></li>
          </ul></li>
          <li><a href="#round-6-奇技淫巧">Round 6 : 奇技淫巧</a><ul>
          <li><a href="#从当前库中快速导出一个节点committag另作他用">从当前库中快速导出一个节点(commit、tag)另作他用</a></li>
          <li><a href="#导出某个子目录及其-log-成为一个新的-repo">导出某个子目录及其 log 成为一个新的 repo</a></li>
          <li><a href="#分支-2-需改-bug但我正在分支-1-上编码并不想-commit-怎么办">分支 2 需改 bug，但我正在分支 1 上编码并不想 commit 怎么办</a></li>
          <li><a href="#modify-错了我要丢弃本地目录中的修改">modify 错了，我要丢弃本地目录中的修改</a></li>
          <li><a href="#add-错了我要丢弃暂存区的修改">add 错了，我要丢弃暂存区的修改</a></li>
          <li><a href="#commit-错了我要丢弃某个-commit-节点">commit 错了，我要丢弃某个 commit 节点</a></li>
          <li><a href="#push-错了我要丢弃-remote-上的某个节点">push 错了，我要丢弃 remote 上的某个节点</a></li>
          <li><a href="#暂存一个文件的部分改动">暂存一个文件的部分改动</a></li>
          <li><a href="#能否从不同的分支里选择某次提交并且把它合并到当前的分支">能否从不同的分支里选择某次提交并且把它合并到当前的分支</a></li>
          <li><a href="#head和head是啥"><code>HEAD^</code>和<code>HEAD~</code>是啥</a></li>
          <li><a href="#如何统计一段时间文件或文件夹的修改次数">如何统计一段时间文件（或文件夹）的修改次数</a></li>
          </ul></li>
          <li><a href="#round-7-原理拾趣">Round 7 : 原理拾趣</a><ul>
          <li><a href="#git-和-svn-在元数据存储上有什么区别">git 和 SVN 在元数据存储上有什么区别</a></li>
          <li><a href="#git-的对象object">git 的对象（object）</a></li>
          <li><a href="#git-的快照存储有点不可思议如何做到好又多的">git 的快照存储有点不可思议，如何做到好又多的</a></li>
          <li><a href="#git-addcommit-原理图">git add/commit 原理图</a></li>
          <li><a href="#git-checkout-原理图">git checkout 原理图</a></li>
          <li><a href="#git-fetchpull-原理图">git fetch/pull 原理图</a></li>
          <li><a href="#git-reset-原理图">git reset 原理图</a></li>
          </ul></li>
          <li><a href="#round-8-git-与-phabricator">Round 8 : git 与 phabricator</a><ul>
          <li><a href="#arc-为何物">arc 为何物</a></li>
          <li><a href="#arc-的安装和配置">arc 的安装和配置</a></li>
          <li><a href="#arc-diff-初步">arc diff 初步</a></li>
          <li><a href="#arc-diff-为什么把我已有的-commit-log-修改了">arc diff 为什么把我已有的 commit log 修改了</a></li>
          <li><a href="#如何避免-arc-diff-玷污现有节点">如何避免 arc diff 玷污现有节点</a></li>
          <li><a href="#如何创建只包含部分文件的评审单">如何创建只包含部分文件的评审单</a></li>
          </ul></li>
          </ul>
        </div>
        <div class="col-sm-9 col-sm-offset-3 col-md-9 col-md-offset-3 main">
        
<h1>
Git 聊天入门
</h1>
<p><strong>自荐</strong><br />
俊建 Kevin<br />
2021.9</p>
<p>由于本文，促成了蓝桥与我的合作网课：<a href="https://www.lanqiao.cn/courses/3083">12 个实验教你轻松进阶 Git</a>，算是作为本文入门系列的延伸吧，网课依然是我的写作风格：由浅入深、逐步上难度、行文随性……但是比本文肯定正式和规范多了，蓝桥的编辑要求也很严格，希望能够帮到有需要的同学。网课与本文几乎没有重复，甚至最好阅读完本文的前 4 章后再读才好。</p>
<p>另外，我还为本文和网课单独申请了一个微博：<a href="https://weibo.com/wbzqm">GiterClub</a>，有什么 git 相关的交流和问题都可以 @、私信我，我不保证及时回复啊，但如果有空且碰巧我会的话，非常乐意与大家共同探讨。</p>
<hr />
<p><strong>自序</strong><br />
俊建 Kevin<br />
2016.2</p>
<p>读一本 Git 的书和读一篇 Git 的文章给人的知识含量是不同的，但给人的愉悦感也是迥异的。本文不想让您有读书的感觉、不追求知识全面、架构完整，但也不想只罗列一些 git 的知识点，搞的像一个 Tip 集。本文会从实际使用的角度，以聊天问答的形式，从浅入深，逐步展露 git 的若干方面。</p>
<p>本文分 Round 进行，每局并不以 git 命令的逻辑来分类，而是以<strong>使用 git 完成任务的水平来分解阶段</strong>。一些问题原本来自于我和朋友们的聊天，闲聊之余，记录成集，不要期待有什么高深的理论，让你每读完一个 Round，可以小试牛刀，然后烹茶小饮、若有所思……是我最想要的。</p>
<p>git 有自己的 <a href="https://www.kernel.org/pub/software/scm/git/docs/user-manual.html">user manunal</a>，和官方宝书（<a href="http://git-scm.com/book/en/v2">英文版</a>、<a href="http://git-scm.com/book/zh/v2">中文版</a>、<a href="http://www.kancloud.cn/kancloud/progit">国内备份</a>），如果你读来无碍，请忽视本文，本文与它们相比只是个小人书、连环画，或者作为它们的一个补充。我在写每个 Topic 的时候也都在想：是不是书里已经有了？我是不是重复了？是不是删掉算了？—— 经常在知识点完整和拾遗之间反复权衡，但想到碎片化阅读越来越普及、学东西主要靠百度的今天，我写点东西发出来应该也是有益的。</p>
<hr />
<h1 id="round-1-起步">Round 1 : 起步</h1>
<p><img src="img/run-buffalo.jpg" /></p>
<h2 id="git-在哪里">git 在哪里</h2>
<ul>
<li>Unix 系（Ubuntu/Fedora/macOS/……）默认就有，打开 terminal，输入<code>git --version</code>，就在那里了</li>
<li>Windows 上要安装：<a href="https://github.com/git-for-windows/git">Git for Windows</a></li>
</ul>
<h2 id="git-for-windows-咋用">Git for Windows 咋用</h2>
<p>一路“下一步”安装完即可。</p>
<p><img src="img/git4windows-install.png" /></p>
<ol type="1">
<li>Git Bash: Linux 风格的命令行，如： /user/bin</li>
<li>Git CMD： Windows 风格的命令行，即：C:</li>
<li>Git GUI: 图形化界面</li>
<li>其实还有一个： ${安装目录}/bin/sh.exe —— 我喜欢直接用这个</li>
</ol>
<p><img src="img/git4windows-sh.png" /></p>
<p>对比一下 1 和 4：</p>
<p><img src="img/git4windows-gitbash.png" /><br />
<img src="img/git4windows-bin.png" /></p>
<ul>
<li>1 和 4 的图标不同，4 其实是 Windows 自身的 cmd 窗口</li>
<li>4 由于是 Windows 自身 cmd 窗口，所以对中文支持较好</li>
</ul>
<p>所以建议您直接用 4：<strong>直接双击或在 cmd 中打开 ${安装目录}/bin/sh.exe 来运行 MinGW 环境和 git</strong></p>
<h2 id="先单机玩玩还是先弄来个别人的-git-库">先单机玩玩还是先弄来个别人的 git 库</h2>
<p>先单机玩玩吧，理由如下：</p>
<p>git 和 svn 最大的区别：</p>
<ul>
<li>svn 是集中式管控：所有库（repo）的内容都在 server 上，离了 server 连 svn log 都看不了，更别说提交代码了</li>
<li>git 是分布式管控：每个 git 项目里面的.git 文件夹中都包括了所有的库（repo）内容，可以看 log、提交代码、创建分支、打 tag……
<ul>
<li>两台电脑的 git 库之间是<strong>同步（sync）</strong>的概念，大家都是平等的</li>
</ul></li>
</ul>
<p>所以说我们还是先练习一下除了 sync 之外的基础命令吧，会了这些之后，至少你能在本机快乐的写日记了。</p>
<blockquote>
<p>我看到有些小伙伴还在用类似 EDiary 等日记本软件或 PIM 软件来写每天的日记，积累了这么多年的日记，一旦 win10 上运行不了 EDiary 可咋整？还是赶紧试试用纯文本+Markdown 来写日记，用 git 本地做版本管理吧！</p>
</blockquote>
<p>下文我使用个人日记的小项目来演示本机的 git 操作</p>
<h2 id="如何在本机-git-我的日记">如何在本机 git 我的日记</h2>
<p>OK，让我们从头开始，跟着做一遍吧，Good Luck ……</p>
<ul>
<li>做一下 git 要求的最基本的两个配置：name 和 email</li>
</ul>
<pre class="cmd"><code>$ git config --global user.name wkevin
$ git config --global user.emal wkevin27@gmail.com</code></pre>
<ul>
<li>创建一个文件夹并写一篇日记</li>
</ul>
<pre class="cmd"><code>MBP:demo wangkevin$ mkdir mydiary
MBP:demo wangkevin$ cd mydiary
$ cat &gt;diary.md
# Diary

## 2016.1.31
回家过年^C
$ ls
diary.md
$ cat diary.md
# Diary

## 2016.1.31
回家过年</code></pre>
<ul>
<li><code>git init</code>:在文件夹中创建 git 库</li>
</ul>
<pre class="cmd"><code>$ git init
Initialized empty Git repository in /Users/wangkevin/workspace/kproject/demo/mydiary/.git/</code></pre>
<ul>
<li>和 SVN 有.svn 类似，git 也有.git</li>
</ul>
<pre class="cmd"><code>$ ls -a
.       ..      .git        diary.md
$ ls .git
HEAD        config      hooks       objects
branches    description info        refs
$ cat .git/config
[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
    logallrefupdates = true
    ignorecase = true
    precomposeunicode = true</code></pre>
<ul>
<li><code>git status</code>：显示一个未被管控的文件(Untracked files) diary.md</li>
</ul>
<pre class="cmd"><code>$ git status
On branch master

Initial commit

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

    diary.md

nothing added to commit but untracked files present (use &quot;git add&quot; to track)</code></pre>
<ul>
<li><code>git add filename</code>：将文件纳入管理，filename 支持通配符，最常用的就是点(.)表示所有文件</li>
</ul>
<pre class="cmd"><code>$ git add diary.md</code></pre>
<ul>
<li><code>git status</code> 显示此文件待提交（to be committed），此时文件已经开始被 git 管理了，文件进入一种暂存状态（stage），如果想反悔可以用<code>git rm --cached</code>使其进入 unstage 状态</li>
</ul>
<pre class="cmd"><code>$ git status
On branch master

Initial commit

Changes to be committed:
  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)

    new file:   diary.md</code></pre>
<ul>
<li><code>git status -s</code> -short 短模式</li>
</ul>
<pre class="cmd"><code>$ git status -s
A  diary.md</code></pre>
<ul>
<li><code>git status -b</code> -branch 显示分支，<code>git status</code>不带参数默认就是-b 的，所以常和短模式合作，合并为一个 sb，哈哈</li>
</ul>
<pre class="cmd"><code>$ git status -sb
## Initial commit on master
A  diary.md</code></pre>
<ul>
<li><code>git commit</code>: 将文件从暂存态提交入库 —— 暂存就像回收站（删除前给你一个 check 的机会，多次操作放入回收站的文件可以一次清空），多次操作放入暂存，最后考虑成熟了，check OK 了，再 commit 提交</li>
</ul>
<pre class="cmd"><code>$ git commit
aster (root-commit) 14dd781] create mydiary
 1 file changed, 4 insertions(+)
 create mode 100644 diary.md</code></pre>
<ul>
<li>执行 <code>git commit</code> 后会自动打开一个编辑器（编辑器是可配置的，以后再说怎么配置），比如 vi，进行提交 log 的撰写，保存退出即提交成功，不保存退出即放弃提交</li>
</ul>
<pre class="vi"><code>  1
  2 # Please enter the commit message for your changes. Lines starting
  3 # with &#39;#&#39; will be ignored, and an empty message aborts the commit.
  4 # On branch master
  5 #
  6 # Initial commit
  7 #
  8 # Changes to be committed:
  9 #   new file:   diary.md
 10 #</code></pre>
<ul>
<li>再查<code>git status</code>，都已经提交干净了</li>
</ul>
<pre class="cmd"><code>$ git status
On branch master
nothing to commit, working directory clean
$ git status -s</code></pre>
<ul>
<li>现在可以看 log 了</li>
</ul>
<pre class="cmd"><code>$ git log
commit 14dd7815fcf56c961e11c52e96e2fc3fbd7d0543
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 11:39:55 2016 +0800

    create mydiary</code></pre>
<ul>
<li>git 和 svn 不同，没有一个数字递增的节点号，而是一串 40Bytes 的哈希字符，指定一个提交只需要给出这个字符串即可，当然不能让你每次都把 40 个字符全输入一遍，只需要输入够区分提交的即可（一般是前 7 位），如果咱的库规模还很小，前 4 位也行哦（下文中的“6784”）</li>
</ul>
<pre class="cmd"><code>$ git lg
 b81373d | 2016-01-31 15:49:08 +0800 | 2016-01-31 15:49:08 +0800 |  wkevin  add .gitignore file
 67840e1 | 2016-01-31 12:20:26 +0800 | 2016-01-31 12:20:26 +0800 |  wkevin  2.2日记
 bf36ab9 | 2016-01-31 12:19:33 +0800 | 2016-01-31 12:19:33 +0800 |  wkevin  2.1的日记
 14dd781 | 2016-01-31 11:39:55 +0800 | 2016-01-31 11:39:55 +0800 |  wkevin  create mydiary
$ git log 6784
commit 67840e1813af1084abd5d07d2e2a2e185c679f09
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 12:20:26 2016 +0800

    2.2日记
</code></pre>
<ul>
<li>每天可以随时写日记、随时<code>git add</code>、适时<code>git commit</code>，经过一段时间，你的 diary 库就越来越让你爱不释手了</li>
</ul>
<pre class="cmd"><code>$ git log
commit 67840e1813af1084abd5d07d2e2a2e185c679f09
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 12:20:26 2016 +0800

    2.2日记

commit bf36ab9b0d489a2eda911be9e01bddc395fc29e0
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 12:19:33 2016 +0800

    2.1的日记

commit 14dd7815fcf56c961e11c52e96e2fc3fbd7d0543
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 11:39:55 2016 +0800

    create mydiary</code></pre>
<ul>
<li>觉得<code>git log</code>默认显示的内容不爽？想看更详细的、或更简略的？——别急，统统没问题，各种参数全方位满足你的各种需求，但这里先不说，后文慢慢来，先不要用这些复杂的参数来打击自己吧，不过来个一步简洁到位的的命令：<code>git shortlog</code> —— 什么？太简洁了？哈哈，别急，从简洁到纸到复杂到翔全都有，慢慢来。</li>
</ul>
<pre class="cmd"><code>$ git shortlog
wkevin (3):
      create mydiary
      2.1的日记
      2.2日记</code></pre>
<hr />
<p>如果只是让 git 管理个<strong>日记本</strong>，自己写、自己看、绝不给别人看、绝不上网……这些命令就差不多够了！</p>
<p>哇！好累啊，可以休息一下了，就这些命令，玩几天，把日记写上一个礼拜，然后我们再继续。如果你不打算继续了，也没关系，这些命令就写日记–够用了！</p>
<p>第一局，Over！</p>
<h1 id="round-2-优雅">Round 2 : 优雅</h1>
<p><img src="img/gray-owl-mouse-sw.jpg" /></p>
<p>欢迎回来，能回来接着读说明你是个积极追求上进的好同学，我们继续聊！</p>
<p>用 git 写了一些日记，你肯定有了新需求，最令你恼火的可能有：</p>
<ul>
<li>敲命令真烦人，尤其还辣么长的命令</li>
<li>看 log 真晃眼，不清爽</li>
<li>提交之前还要来个 add，啥子意思</li>
</ul>
<h2 id="每次都要敲-addcommitstatus嫌累了">每次都要敲 add、commit、status，嫌累了</h2>
<p>有这样的问题说明你已经是 git 的初级用户了，并且听了我的建议：“使用命令行，远离 GUI” —— 我一点都不奇怪，绝大部分程序猿一旦用上 git 都会上瘾的，会频繁的<code>git commit</code>，然后在<code>git log</code>中寻觅自己的成就感，否则吃不好饭、睡不好觉……呵呵</p>
<p>言归正传。</p>
<p>别名（alias）是 linux 系统的基本概念，在 git 中也如鱼得水：</p>
<ul>
<li>这样设置别名</li>
</ul>
<pre class="cmd"><code>$ git config --global alias.st  &quot;status&quot;</code></pre>
<ul>
<li>然后就可以这样操作了</li>
</ul>
<pre class="cmd"><code>$ git st
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   diary.md

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre>
<ul>
<li>换个别名玩玩</li>
</ul>
<pre class="cmd"><code>$ git config --global alias.st  &quot;status -sb&quot;
$ git st
## master
 M diary.md</code></pre>
<ul>
<li>把让你烦的命令都用 2 个字来别名一下吧。比如：</li>
</ul>
<pre class="cmd"><code>$ git config --global alias.ci  &quot;commit&quot;</code></pre>
<h2 id="有些文件不希望被-git-管理">有些文件不希望被 git 管理</h2>
<p>问：markdown 写的 diary.md ，会在本地生成 diary.html 检查和欣赏一下，但其实是不需要 commit 的，如何在 <code>git commit</code> 的时候忽略它们。</p>
<p>答：<code>git commit</code>的时候已经不能忽略了，要忽略需要在<code>git add</code>的时候，通过编辑<strong>.gitignore 文件</strong>让 add 命令忽略它们。</p>
<ul>
<li>diary.html 就是我们不想提交的过程文件</li>
</ul>
<pre class="cmd"><code>$ git st
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   diary.md

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

    diary.html

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre>
<ul>
<li>手工生成一个<strong>.gitignore</strong>的文件，写入含有通配符的文件名（即：后缀名为 html 的文件）</li>
</ul>
<pre class="cmd"><code>$ cat &gt;.gitignore
*.html
^C
$ cat .gitignore
*.html</code></pre>
<ul>
<li>diary.html 已经被自动忽略。</li>
</ul>
<pre class="cmd"><code>$ git st
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   diary.md

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

    .gitignore

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre>
<h2 id="我要筛选-git-log">我要筛选 git log</h2>
<ul>
<li>可以只看某个子目录或某个文件的 log</li>
<li>可以从某个提交开始看</li>
</ul>
<pre class="cmd"><code>$ git log 6784
commit 67840e1813af1084abd5d07d2e2a2e185c679f09
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 12:20:26 2016 +0800

    2.2日记</code></pre>
<ul>
<li>可以只看某个人的 log</li>
</ul>
<pre class="cmd"><code>$ git log --author=wkevin
commit 67840e1813af1084abd5d07d2e2a2e185c679f09
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 12:20:26 2016 +0800

    2.2日记
……</code></pre>
<ul>
<li>–author 支持匹配</li>
</ul>
<pre class="cmd"><code>$ git log --author=wke
commit 67840e1813af1084abd5d07d2e2a2e185c679f09
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 12:20:26 2016 +0800

    2.2日记
……</code></pre>
<ul>
<li>–author 的一个错误匹配</li>
</ul>
<pre class="cmd"><code>$ git log --author=wken
$</code></pre>
<ul>
<li>–author 上使用通配符</li>
</ul>
<pre class="cmd"><code>$ git log --author=wke.*n
commit 67840e1813af1084abd5d07d2e2a2e185c679f09
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Sun Jan 31 12:20:26 2016 +0800

    2.2日记</code></pre>
<h2 id="觉得-git-log-中的时间看着困难精简下呗">觉得 git log 中的时间看着困难，精简下呗</h2>
<ul>
<li>使用 –date=short</li>
</ul>
<pre class="cmd"><code>$ git log --pretty=medium --date=short
commit 67840e1813af1084abd5d07d2e2a2e185c679f09
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   2016-01-31

    2.2日记

commit bf36ab9b0d489a2eda911be9e01bddc395fc29e0
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   2016-01-31

    2.1的日记

commit 14dd7815fcf56c961e11c52e96e2fc3fbd7d0543
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   2016-01-31

    create mydiary</code></pre>
<h2 id="我要定制-git-log不想一页看不了几条">我要定制 git log，不想一页看不了几条</h2>
<p>默认的<code>git log</code>一条 commit log 至少需要 6 行来显示，一页顶多看个 5、6 条，很不方便。如果单条达到 10 行的话，一页也就看个 2、3 条。像 linux 这样的项目，经常遇到长篇大论的 log，内容倒是详实了，但很难做一览表式的查询。</p>
<p>下面我们祭出 git log 的必杀技： –pretty 或 –format</p>
<p><code>git log --pretty=xxx</code> 等价于 <code>git log --format=xxx</code>, xxx 可以是这些：</p>
<ul>
<li>oneline：只显示一行</li>
<li>short</li>
<li>medium</li>
<li>full</li>
<li>fuller：会看到有两个角色：author（作者） 和 commit（提交人）</li>
<li>email</li>
<li>raw</li>
<li>format:‘……’</li>
</ul>
<p>其中<code>oneline</code>能够帮你精简 log</p>
<pre class="cmd"><code>$ git log --pretty=oneline
67840e1813af1084abd5d07d2e2a2e185c679f09 2.2日记
bf36ab9b0d489a2eda911be9e01bddc395fc29e0 2.1的日记
14dd7815fcf56c961e11c52e96e2fc3fbd7d0543 create mydiary</code></pre>
<p>其实 <code>--oneline</code> 也是一个单独的参数</p>
<pre class="cmd"><code>$ git log --oneline
67840e1 2.2日记
bf36ab9 2.1的日记
14dd781 create mydiary</code></pre>
<h2 id="oneline-太简陋了一行里面看到-hashauthordatemessage">oneline 太简陋了，一行里面看到 hash、author、date、message</h2>
<p>那需要用上 –pretty=formate:“……”参数了</p>
<p>format 参数很多，没必要逐一掌握，除了你是强迫症患者 – 凑巧本文不使用强迫症的视角，哈哈</p>
<p>我常用的有：</p>
<ul>
<li>%h：commit hash</li>
<li>%ai: author date</li>
<li>%an: author name</li>
<li>%ci: commit date</li>
<li>%cn: commit name</li>
<li>%s: log message</li>
</ul>
<p>示例：</p>
<ul>
<li>只看日期、作者、log（专业术语是：subject）</li>
</ul>
<pre class="cmd"><code>$ git log --pretty=format:&#39;%ad %an %s&#39;
Sun Jan 31 15:49:08 2016 +0800 wkevin add .gitignore file
Sun Jan 31 12:20:26 2016 +0800 wkevin 2.2日记
Sun Jan 31 12:19:33 2016 +0800 wkevin 2.1的日记
Sun Jan 31 11:39:55 2016 +0800 wkevin create mydiary</code></pre>
<ul>
<li>日期太碍眼，精简一下</li>
</ul>
<pre class="cmd"><code>$ git log --pretty=format:&#39;%ad %an %s&#39; --date=short
2016-01-31 wkevin add .gitignore file
2016-01-31 wkevin 2.2日记
2016-01-31 wkevin 2.1的日记
2016-01-31 wkevin create mydiary</code></pre>
<ul>
<li>不好了，但太精简了，咋只有 date，没有 time</li>
</ul>
<pre class="cmd"><code>$ git log --pretty=format:&#39;%ad %an %s&#39; --date=local
Sun Jan 31 15:49:08 2016 wkevin add .gitignore file
Sun Jan 31 12:20:26 2016 wkevin 2.2日记
Sun Jan 31 12:19:33 2016 wkevin 2.1的日记
Sun Jan 31 11:39:55 2016 wkevin create mydiary</code></pre>
<ul>
<li>commit hash 最好也能加上</li>
</ul>
<pre class="cmd"><code>$ git log --pretty=format:&#39;%h %ad %an %s&#39; --date=local
b81373d Sun Jan 31 15:49:08 2016 wkevin add .gitignore file
67840e1 Sun Jan 31 12:20:26 2016 wkevin 2.2日记
bf36ab9 Sun Jan 31 12:19:33 2016 wkevin 2.1的日记
14dd781 Sun Jan 31 11:39:55 2016 wkevin create mydiary</code></pre>
<p>最后，你还需这样：</p>
<pre class="cmd"><code>$ git config --global --replace-all alias.lg   &quot;log --pretty=format:&#39;%h %ad %an %s&#39; --date=local&quot;</code></pre>
<h2 id="git-log-已经很好了但好像还是缺点啥">git log 已经很好了，但好像还是缺点啥</h2>
<p>那就是颜色了，加上颜色让字段分的更加清晰</p>
<pre class="cmd"><code>git config --global --replace-all alias.lg  &quot;log --pretty=format:&#39;%C(auto) %h | %ai | %Cred %an %Cgreen %s&#39;&quot;</code></pre>
<p><img src="img/git-lg-with-color.png" /></p>
<p>为什么改用<code>%ai</code>，不用<code>%ad</code>了？<br />
<code>%ad</code>会受到<code>--date=xxx</code>的影响，<code>%ai</code>不会。所以限制了<code>%ad</code>的使用，如果常从 github 上拿代码，会看到世界各地的提交人和提交时间，我还是希望分一下时区的，所以用了<code>%ai</code>。</p>
<p>比如我们来查看 linux 的源码：</p>
<p><img src="img/git-lg-by-linux.png" /></p>
<h2 id="git-log-fuller-中的-author-和-commit-啥关系">git log –fuller 中的 author 和 commit 啥关系</h2>
<p>必须要说了，git 的设计者的设计思路是：希望提交人（执行<code>git commit</code>的人）能够把 author 写明白，而不是据为己有。所以 git 的作者（author）和提交人（commit）可以不是同一个人。</p>
<pre class="cmd"><code>$ git commit --author=wkevin --date=&#39;2016-01-30 22:04:04 +0800&#39;</code></pre>
<p>上面的命令可以在 commit 的同时指定提交内容的 author 和 AUTHOR_DATE，这个恐怕要靠提交者（committer）的记忆力和公德心了，把这段代码真实 author 的名字和写就时间录进去，而不是让 git 默认的把自己的 name 和提交时间（COMMITTER_DATE）录入库中。</p>
<p>在没有 github 之前，一个开源项目通常还是只设置几个有权限的提交人，大家想贡献代码就发 patch 给有权限的人，然后有权人 commit。但自从有了 github，发明了 fork（fork 并不属于 git，而是 github 的独创哦）和 PR（Pull-Request），让这个过程更加的轻便，也让项目的发展更加《失控》，有能力的人可以在自己的领地 fork 并发展一个项目，PR 或不 PR 给原作者全凭个人喜好，原作者如果“懒政”，其他人完全可以独立发展。—— 每个人都在自己的库里 commit，使得 committer 和 author 通常都是一个人，大家都是通过 PR 给其他人，而不是发送 patch 了。—— 所以 <code>--author</code> 这个参数已经很久不用一次了。</p>
<h2 id="看-log-的时候能否把修改了哪些文件也列出来">看 log 的时候能否把修改了哪些文件也列出来</h2>
<pre class="cmd"><code>$ git log --stat</code></pre>
<h2 id="看-tag-的时候能否把日期时间也列出来">看 tag 的时候能否把日期时间也列出来</h2>
<p><code>git tag</code> 貌似是完成不了这个任务，只能拜托<code>git log</code>了。</p>
<p>关键是 <code>--simplify-by-decoration</code> 参数， refs/heads 和 refs/tags 都算一种 decoration，再联合 –tags 就可以了：</p>
<pre class="cmd"><code>$ git log --tags --simplify-by-decoration --pretty=&quot;format:%ci %d&quot;</code></pre>
<p>下面这句可以按常规 log 来显示，每个 hash 后面跟的就是 tag</p>
<pre class="cmd"><code>$ git log --decorate=full --simplify-by-decoration</code></pre>
<p>或者用 for-each-ref 命令也是极好的：</p>
<pre class="cmd"><code>$ git for-each-ref --format=&quot;%(creatordate)  %(refname:short) &quot; refs/tags/*</code></pre>
<h2 id="我要能像-tortoisesvn-那样左右两栏对比看-diff">我要能像 TortoiseSVN 那样左右两栏对比看 diff</h2>
<p>这个必须有！</p>
<blockquote>
<p>git 和 TortoiseSVN 相比是不恰当的，git 要和 subversion 比较，它们两个是协议；TortoiseGit 才是和 TortoiseSVN 比较，这两个是前端。Subversion 的前端并不多，除了 TortoiseSVN 并没有更多的选择，git 的前端却不少：TortoiseGit、GitForWindows、Github for Desktop……</p>
</blockquote>
<blockquote>
<p>前端对协议进行了封装（比如默认安装的 TortoiseSVN 都已经找不到<code>svn</code>等命令，所以也不能运行<code>svn log</code>、<code>svn commit</code>）和更多的图形化工作（图标重绘、文本比较工具……）的事情留在后面慢慢说，回到比较工具上来：除非你是要制作补丁包，或者改动很小，否则你几乎不会想直接查看<code>git diff</code>，配置好第三方比较工具的调用方法是必须要做的 —— 这个懒偷不得。</p>
</blockquote>
<blockquote>
<p>git 调用第三方工具是灵活的，当然 TortoiseSVN 调用第三方 diff/Merge 工具也是可定制的，并且用户不指定第三方工具的话，TortoiseSVN 项目自己做了一个比较工具 TortoiseMerge 来作为默认，TortoiseGit 也是有默认的。git 则需要手工设置。</p>
</blockquote>
<p><strong>git 中查看差异有两个命令</strong>:</p>
<ol type="1">
<li><code>git diff</code>: 在 Terminal 中按照 Linux 的传统方式生成 patch<br />
<img src="img/git-diff.png" /></li>
<li><code>git difftool</code>: 使用第三方工具显示差异<br />
<img src="img/git-difftool-merge.png" /></li>
</ol>
<p><code>git difftool</code> 命令能够调用的第三方比较工具有很多，列几个本人用过的：</p>
<ul>
<li>收费的
<ul>
<li><a href="http://www.scootersoftware.com">Beyond Compare</a> – Win、Linux、macOS</li>
<li><a href="http://www.araxis.com">Araxis Merge</a> – Win、macOS</li>
<li><a href="http://www.ultraedit.com/products/ultracompare.html">UltraCompare</a> – Win,本来是 UE 的一个插件，近几年独立出来了</li>
</ul></li>
<li>免费但不开源的
<ul>
<li><a href="http://www.sourcegear.com/diffmerge/downloads.php">DiffMerge</a> – Win、Linux、macOS</li>
</ul></li>
<li>开源的：
<ul>
<li><a href="http://meldmerge.org">Meld</a> – Win、Linxu、macOS</li>
</ul></li>
</ul>
<p>用哪个呢？这是萝卜白菜的事情，不要纠结，你用惯了哪个就是哪个（我相信你的电脑上肯定已经有了一个文本比较工具，用它就是了，本着开放、开源、和跨平台的原则，我个人推荐 Meld）。git 调用它们的方法配置是大同小异。我不能每种软件在每个系统中都试一遍，所以只能条目列在这里，但我本人没搞过的就空着了，看官自己百度一下吧，照葫芦画瓢能力强的话也用不着百度。</p>
<ul>
<li><strong>Araxis Merge</strong>
<ul>
<li>macOS: <code>vi ~/.gitconfig</code>，加入：</li>
</ul>
<pre><code>difftool.prompt=false
diff.tool=araxis
merge.tool=araxis
mergetool.araxis.path=/Applications/Araxis Merge.app/Contents/Utilities/compare
difftool.araxis.path=/Applications/Araxis Merge.app/Contents/Utilities/compare</code></pre>
<ul>
<li>Linux</li>
<li>Windows</li>
</ul></li>
<li><strong>BeyondCompare</strong>
<ul>
<li>macOS</li>
<li>Linux</li>
<li>Windows</li>
</ul>
<pre class="cmd"><code>$ git config --global diff.tool bc3
$ git config --global difftool.bc3.path &quot;c:/program files/beyond compare 3/bcomp.exe&quot;</code></pre></li>
<li><strong>DiffMerge</strong>
<ul>
<li>macOS</li>
<li>Linux</li>
<li>Windows</li>
</ul>
<pre class="cmd"><code>$ git config --global diff.tool diffmerge
$ git config --global difftool.diffmerge.cmd &#39;diffmerge &quot;$LOCAL&quot; &quot;$REMOTE&quot;&#39;</code></pre></li>
<li><strong>Meld</strong>
<ul>
<li>macOS</li>
<li>Linux</li>
<li>Windows</li>
</ul></li>
</ul>
<p>除此之外，还可以配置一项：</p>
<pre class="cmd"><code>$ git config --global difftool.prompt false</code></pre>
<p>OK，弄好了吧，我们来总结一下其知识点，如果不想看，可以跳过去看下条了。</p>
<ul>
<li>配置方法两种：
<ol type="1">
<li>通过 <code>git config ...</code> 命令</li>
<li>通过 <code>vi ~/.gitconfig</code> 直接修改 git 的配置文件，方法 1 最终也是落实到 2 上</li>
</ol></li>
<li>配置命令有两个：
<ol type="1">
<li>cmd：git 在执行某个 difftool 的时候，执行的命令，用户没有定义的话，会使用 tool 的名字做默认启动；如果用户定义的话，就必须加上 $LOCAL $REMOTE</li>
<li>path: 用于定位不在 PATH 变量里的命令，但不需要加 $LOCAL $REMOTE</li>
</ol></li>
</ul>
<p>肯定还是有些完美主义者，一台电脑上安装了多个比较软件，想要不断切换 —— 也是没问题的。</p>
<ul>
<li>可以配置多个 cmd</li>
</ul>
<pre class="cmd"><code>$ git config --global difftool.bc.cmd &#39;beyondcompare &quot;$LOCAL&quot; &quot;$REMOTE&quot;&#39;
$ git config --global difftool.am.cmd &#39;araxismerge &quot;$LOCAL&quot; &quot;$REMOTE&quot;&#39;
$ git config --global difftool.dm.cmd &#39;diffmerge &quot;$LOCAL&quot; &quot;$REMOTE&quot;&#39;</code></pre>
<ul>
<li>根据需求随时切换</li>
</ul>
<pre class="cmd"><code>$ git config --global diff.tool bc</code></pre>
<p>或</p>
<pre class="cmd"><code>$ git config --global diff.tool am</code></pre>
<p>或</p>
<pre class="cmd"><code>$ git config --global diff.tool dm</code></pre>
<h2 id="修改完了为什么不是直接提交而是-git-add">修改完了为什么不是直接提交，而是 git add</h2>
<p>git 在 <code>git commit</code> 之前首先要 <code>git add</code>，从 svn 转移过来的同学会对这点有一些疑惑和质疑。</p>
<p><code>git add</code> 将文件放入到暂存区（stage），并生成对象 —— 参见本文的 <a href="#git-object">git 的对象（object）</a></p>
<p>理解 git 需要理解文件的 5 种状态和 3 个区（area）：</p>
<p>5 种状态：</p>
<ol type="1">
<li>未跟踪态（untracked）</li>
<li>未修改状态（unmodified）</li>
<li>修改状态（modified），即：待暂存（staging）</li>
<li>已暂存（staged）</li>
<li>已提交（committed）</li>
</ol>
<p>3 个区：</p>
<ol type="1">
<li>本地工作目录（working directory）</li>
<li>暂存区（staging area，又叫做 index）</li>
<li>git 库（repository）</li>
</ol>
<p>1、2、3 状态在本地工作目录，4 状态属于暂存区，5 状态属于 git 库。</p>
<embed src="img/git-state-and-area.svg" type="image/svg+xml" />
<p>如果我修改了一下 README.md，<code>git add</code>了一下，然后又修改了一下，用<code>git st</code>的打印是这样的：</p>
<pre class="cmd"><code>$ git st
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    modified:   README.md

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   README.md</code></pre>
<p>很多地方把暂存和 stage 混在一起，不查字典的话还以为 stage 的中文翻译就是暂存。其实 stage 就这个单词的本身的意思是：</p>
<ol type="1">
<li>名词：舞台、讲台，比如：戏剧表演的舞台、国际政治的舞台；阶段，类似 phase，比如：stage one/two 意思是第一/二阶段，three-stage rocket 意思是三级火箭</li>
<li>动词：上演、举行、组织，类似 play、organize，比如：stage a football match，举办足球赛</li>
</ol>
<p>stage 本身并没有暂存的意思，git 中可以理解为把文件放到一个舞台上上演一下，进而文件进入到一个新的阶段。——用这个词可以说是一箭三雕。</p>
<p>你可以输入<code>git help stage</code> 看看</p>
<pre class="cmd"><code>GIT-STAGE(1)                                              Git Manual                                              GIT-STAGE(1)
NAME
       git-stage - Add file contents to the staging area
SYNOPSIS
       git stage args...
DESCRIPTION
       This is a synonym for git-add(1). Please refer to the documentation of that command.</code></pre>
<p><code>git stage</code> 是同义于 <code>git add</code> 的：将文件加入到 <strong>staging area</strong>（舞台区、阶段区、进而翻译为暂存区，下文我还是尽量不去翻译这个词汇，而直接用英文吧，或搞个缩写：SA —— 如果让我翻译，我会译为：检视区）。</p>
<p>把前面已经提到过暂存区像回收站，把文件放在回收站是给操作人一个检视的机会和反悔的机会，操作妥当后再彻底删除，彻底删除后再想反悔就要费劲了。git 的 staging area 也是给用户一个<strong>检视的机会</strong>和<strong>反悔的机会</strong>，用户可以：</p>
<ul>
<li>使用<code>git add</code>或<code>git stage</code>命令随时向 SA 增加文件，和回收站不同的是后进入 SA 的文件会覆盖前面进入的</li>
<li>使用<code>git checkout</code>命令随时从 SA 反悔，文件会从 SA 移除，是否覆盖</li>
</ul>
<h2 id="我用-ubuntu我要修改-git-commit-时的默认编辑器">我用 ubuntu，我要修改 git commit 时的默认编辑器</h2>
<p><code>git commit</code>会自动打开系统默认的编辑器来让你写 log，如下修改：</p>
<pre class="cmd"><code>ubuntu$ update-alternatives --config editor</code></pre>
<p>这个问题不属于 git 的范畴，而是 linux 的。</p>
<hr />
<p>到这里，你应该能够优雅地使用 git 管理自己的日记本了：<strong>log 清清爽爽、命令简简单单、变更一目了然</strong> —— 如果只是管理自己的日记项目，已然可以游刃有余了。</p>
<p>如果你是工程师或程序员，还会有多版本、多分支并行开发的需求，下面我们开始讨论分支、合并等操作。如果不是程序员，基本上可以刀枪入库、马放南山，结束阅读了。</p>
<p>第二局，Over!</p>
<h1 id="round-3-并发">Round 3 : 并发</h1>
<p><img src="img/boy-buffaloes-india-sw.jpg" /></p>
<p>并发：并行开发，将会涉及分支（创建、查询、删除……）、标签等。</p>
<h2 id="我想使用个分支branch怎么做">我想使用个分支（branch），怎么做</h2>
<p>好了，这里要提到一个非常重要的概念了，很多 git 书籍都会强调的一点：<strong>git 的 branch 只是个指针</strong> —— 也常被称作“<strong>git 的必杀技</strong>”。</p>
<p>下面这几步非常有必要：</p>
<ul>
<li>看一下《Pro Git》中的<a href="http://www.kancloud.cn/kancloud/progit/70182">分支这一章</a></li>
<li>网文非常多，自行搜索一下 <code>git branch</code></li>
<li><code>$ git help branch</code></li>
</ul>
<p>我来概要的描述一些要点</p>
<ul>
<li><code>git init</code>后会自动创建一个 master 分支，它并不是一个多么特殊的分支，跟其他分支没什么区别。</li>
<li>git 中的 3 个区：本地工作目录、索引区、库 —— 分支信息保存在库中，工作目录和索引区都对应库中的某个分支。《Pro Git》中的<a href="http://www.kancloud.cn/kancloud/progit/70182">分支这一章</a>中的图大多都是画的库中的样子，请注意还有工作目录和索引区。</li>
<li>git 的库中保存单元是<a href="#git-object">git 的对象（object）</a>，我们通常脑海中出现的像一颗树一样成长的分支树是由一个个 commit 对象连成的。</li>
<li>HEAD 指针比较特殊，可以将 HEAD 想象为当前分支的别名</li>
</ul>
<h2 id="如何在分支间来回切换">如何在分支间来回切换</h2>
<h2 id="删除分支总是想用-git-branch-delete">删除分支总是想用 git branch delete</h2>
<p>曾经我也愤怒过这个事情：</p>
<ul>
<li>增加一个 remote 是：<code>git remote add ...</code>，增加一个 branch 却是：<code>git branch ...</code> —— 为啥不要 add？</li>
<li>删除一个 remote 是：<code>git remote remove ...</code>，删除一个 branch 却是：<code>git branch -d ...</code> —— 为啥要用<code>-d</code>？</li>
<li>那些年闹过的笑话：
<ul>
<li><code>git branch delete xyz</code>: 结果增加了两个分支：delete 和 xyz</li>
<li><code>git branch remove delete xyz</code>: 以为用错了，再试 remove，结果又增加了第 3 个分支：remove</li>
<li>非常疑惑，再试：<code>git branch del remove delete xyz</code>: 结果可想而知</li>
<li>最后还得： <code>git help branch</code></li>
<li><code>git branch -d del remove delete xyz</code></li>
</ul></li>
</ul>
<p>在用参数还是用子命令的问题上，其实也不要纠结，子命令还能加参，所以子命令相当于对参数进行了一级分类，或者纯粹是开发者的个人偏好。</p>
<ul>
<li>git 中使用子命令的不多：<code>git &lt;command&gt; &lt;subcommand&gt; &lt;option&gt;</code>
<ul>
<li><code>git bisect &lt;subcommand&gt;</code></li>
<li><code>git bundle &lt;subcommand&gt;</code></li>
<li><code>git credential &lt;subcommand&gt;</code></li>
<li><code>git notes &lt;subcommand&gt;</code></li>
<li><code>git p4 &lt;subcommand&gt;</code></li>
<li><code>git remote &lt;subcommand&gt;</code></li>
<li><code>git stash &lt;subcommand&gt;</code></li>
<li><code>git subtree &lt;subcommand&gt;</code></li>
<li><code>git svn &lt;subcommand&gt;</code></li>
<li><code>git worktree &lt;subcommand&gt;</code></li>
</ul></li>
<li>剩下的基本都是： <code>git &lt;command&gt; &lt;option&gt;</code></li>
</ul>
<h2 id="分支的合并git-merge有哪几种场景">分支的合并（git merge）有哪几种场景</h2>
<p><code>git merge</code> = <code>diff</code> + <code>patch</code></p>
<p>假定：本地工作目录是 b1(HEAD)的，希望从 b2 合并过来，b1 和 b2 从同一个节点 C3 继承</p>
<p>初始状态：</p>
<pre><code>              b1(HEAD)
              |
C1 --- C2 --- C3
              |
              b2</code></pre>
<ol type="1">
<li><strong>我动了，队友没动</strong>：b2 自 C3 后没有提交，无论本地文件有无修改、有无暂存、b1 有无新提交：<code>git merge b2</code>后，b1 都<strong>不发生任何变化</strong></li>
</ol>
<pre><code>                            b1(HEAD)
                            |
C1 --- C2 --- C3 --- C6 --- C7
              |
              b2</code></pre>
<ol start="2" type="1">
<li><strong>我没动，队友动了</strong>：C3 后 b1 没有提交，b2 有提交 —— <strong>b1 如果有本地修改或暂存未提交是禁止 merge 操作的</strong>
<ul>
<li>merge 前状态</li>
</ul>
<pre><code>                b1(HEAD)
                |
C1 --- C2 --- C3
                \
                C4 --- C5
                        |
                        b2</code></pre>
<ul>
<li><code>git merge b2</code>后，b1 快速前移（fast-forward）到 b2</li>
</ul>
<pre><code>                            b1(HEAD)
                            |
C1 --- C2 --- C3 --- C4 --- C5
                            |
                            b2</code></pre>
<ul>
<li><code>git merge --no-ff b2</code>后，b1 即使可以快速前移（fast-forward），也会生成一个 commit，就像 b1 有提交似得，其实 C6 里面没有任何文件的修改，只是为给自己和团队人员提个醒，此处做过一次合并 —— merge 一个 anotated tag 的时候用此默认参数</li>
</ul>
<pre><code>                        b1(HEAD)
                        |
C1 --- C2 --- C3 ------ C6
                \       /
                C4 --- C5
                        |
                        b2</code></pre></li>
<li><strong>我和队友都动了</strong>: b1、b2 在 C3 后有提交 —— <strong>同样：b1 如果有本地修改或暂存未提交是禁止 merge 操作的</strong>
<ul>
<li>merge 前状态</li>
</ul>
<pre><code>                    b1(HEAD)
                    |
C1 --- C2 --- C3 -- C6
                \
                C4 --- C5
                        |
                        b2</code></pre>
<ul>
<li><code>git merge b2</code>后，
<ul>
<li>如果没有冲突
<ul>
<li>默认参数是： <code>--commit/</code>，<code>--edit/</code>，即：会产生一次 commit，自动生成 log 但会弹出编辑器给用户编辑，并且<code>git log b1</code>的时候会列出 C1/2/3/4/5/6/7 所有的提交信息</li>
</ul>
<pre><code>                            b1(HEAD)
                            |
C1 --- C2 --- C3 -- C6 -- C7
                \         /
                C4 --- C5
                        |
                        b2</code></pre>
<ul>
<li><code>git merge --no-edit b2</code>可以不弹出编辑器给用户编辑 log</li>
<li><code>git merge --no-commit b2</code>可以避免自动生成 commit，而只是把 b2 的差异合并到本地文件，并 add 到暂存区，后续由开发者自己提交。提交后的新节点 C7 仍是有两个父节点的（C5、C6）</li>
</ul>
<pre><code>                       本地文件 -&gt; 暂存区
                       /     /           \
                      /     /    手动commit  b1(HEAD)
                     /     /               \ |
C1 --- C2 --- C3 -- C6..../.................C7
                \        /                 /
                C4 --- C5  .............../
                        |
                        b2</code></pre>
<ul>
<li><code>git merge -squash b2</code>：sqush 单词的意思是挤压、压扁。此命令可以把 b2 中的差异提交合并成 diff，patch 到本地文件并 add，用户 commit 后生成的新节点和 b2 没有任何关系（<code>git log</code>是看不到 b2 的所有提交的），可以理解为纯粹从 b2 拿差异过来，但又不和 b2 发生关系。—— 常用于在主干上合并一个没有完成的特性分支，或者两个相互依赖的分支不定时的互相合并。</li>
</ul>
<pre><code>                       本地文件 -&gt; 暂存区
                       /     /           \
                      /     /    手动commit  b1(HEAD)
                     /     /               \ |
C1 --- C2 --- C3 -- C6..../.................C7
                \        /
                C4 --- C5
                        |
                        b2</code></pre></li>
<li>如果有冲突，则会分成 2 步：
<ul>
<li>首先在本地文件中记录差异(diff)</li>
</ul>
<pre><code>                        本地文件(diff文件)
                            / /
                    b1(HEAD) /
                    |       /
C1 --- C2 --- C3 -- C6     /
                \         /
                C4 --- C5
                        |
                        b2</code></pre>
<ul>
<li>然后需要手工（使用 vi、notepad++、sublimetext 等删除诸如“===”和“***”）或<code>git mergetool confilctfile</code>两种方式之一修改冲突文件，手工修改完毕后还需<code>git add</code>，<code>git mergetool</code>退出时 git 默认会把冲突文件 add 到暂存区，最后<code>git commit</code>，此时会发现默认的 log 已经被自动加上了</li>
</ul>
<pre><code>                    本地文件(diff文件) -- &quot;手工+git add&quot;或&quot;git mergetool&quot;
                       /      /                                          \
                      /      /                                   手动commit  b1(HEAD)
                     /      /                                              \ |
C1 --- C2 --- C3 -- C6 --- / -----------------------------------------------C7
                \         /                                                /
                C4 --- C5 ------------------------------------------------/
                        |
                        b2</code></pre></li>
</ul></li>
</ul></li>
</ol>
<h2 id="合并时如何处理分支中的垃圾log">合并时如何处理分支中的“垃圾”log</h2>
<p>我想你所表达的所谓“垃圾”只是针对分支要合并到主干了，这些 log 显得琐碎而多余，针对主干来说是“垃圾”，在分支开发过程中这些肯定不是垃圾，而是有效的防护网，也是向领导汇报工作时的“烂笔头”。</p>
<p>我建议你在分支开发过程中可以适当的多提交一些、提交细一些，不但可以省去单独写“工作日志”，也利于回忆和追溯，如果领导在关注这个 git 库，也能让领导感觉每天都在努力，挣一些情感分。</p>
<p>但毕竟好又多的 log 信息合入主干的话还是要认真思考一下是不是要保留所有 log</p>
<ul>
<li><strong>Yes</strong>:那就直接<code>git merge featurebranch master</code></li>
<li><strong>No</strong>:那还是悠着点<code>git merge --squash featurebranch master</code> —— 具体原理参考 <a href="#git-merge">分支的合并（git merge）有哪几种场景</a> 已描述</li>
</ul>
<h2 id="把特性分支合入主干和把主干合入特性分支有什么区别">“把特性分支合入主干”和“把主干合入特性分支”有什么区别</h2>
<p>这个问题问的好，很多一开始接触 git 的同学基本意识不到这个问题。这已经不是 git 本身的问题了，而是使用 git 的团队之间的工作流规范了。</p>
<ul>
<li><strong>把特性分支合入主干</strong>：通常是特性分支开发完毕了，测试通过了，是时候在主干上构建版本了，才把分支合入主干
<ul>
<li>此时通常会遇到前面讲的“处理分支中的垃圾 log”问题，处理办法前文已述</li>
<li>合入主干后分支通常会删除，留着特性分支不删除的习惯是不合适的，用句成语来形容就是：敝帚自珍</li>
<li>删除后还想再继续，<code>git branch featurebranch</code>再开一个就是了，名字都可以相同</li>
<li>通常我们的特性分支是根据用户故事/工单而来的，一个长期不删除的分支说明了任务分解的不合理或需求的不明确，一旦出现这样的问题还是尽快和用户讨论需求并合理的分解。</li>
</ul></li>
<li><strong>把主干合入特性分支</strong>：通常是主干在不停的合入较稳定的代码，分支也想不定期/或定期的同步过来，以免和主干背离太远
<ul>
<li>定期同步主干到特性分支是个好习惯，可以尽快的发现团队成员做了什么，是不是对我的当前分支有影响和冲突……有了冲突要今早发现、尽快处理才是敏捷，对冲突采取鸵鸟策略是不明智的。</li>
<li>涉及的命令有：
<ul>
<li><code>git rebase master</code></li>
<li><code>git pull --rebase</code> 如果有冲突会停住，然后<code>git mergetool</code>解决冲突，<code>git rebase --continue</code>继续</li>
</ul></li>
</ul></li>
</ul>
<h2 id="git-merge-有没有图形化的工具">git merge 有没有图形化的工具</h2>
<p>和 <code>git difftool</code> 类似，也有 <code>git mergetool</code>，但 mergetool 不是用来 merge 的，而是用来处理 merge 后的冲突文件的。</p>
<ul>
<li>通用配置</li>
</ul>
<pre class="cmd"><code>$ git config --global mergetool.diffmerge.trustExitCode true</code></pre>
<ul>
<li><strong>BeyondCompare</strong>
<ul>
<li>macOS</li>
<li>Linux</li>
<li>Windows</li>
</ul>
<pre class="cmd"><code>$ git config --global merge.tool bc3
$ git config --global mergetool.bc3.path &quot;c:/program files/beyond compare 3/bcomp.exe&quot;
$ git mergetool</code></pre></li>
<li><strong>DiffMerge</strong>
<ul>
<li>macOS</li>
<li>Linux</li>
<li>Windows</li>
</ul>
<pre class="cmd"><code>$ git config --global merge.tool diffmerge
$ git config --global mergetool.diffmerge.cmd &#39;diffmerge --merge --result=&quot;$MERGED&quot; &quot;$LOCAL&quot; &quot;$(if test -f &quot;$BASE&quot;; then echo &quot;$BASE&quot;; else echo &quot;$LOCAL&quot;; fi)&quot; &quot;$REMOTE&quot;&#39;</code></pre></li>
</ul>
<h2 id="git-分支之间的关系能否图示">git 分支之间的关系能否图示</h2>
<pre class="cmd"><code>$ git log --pretty=oneline --graph

* 94688f21cc5d8bc85f1783b4c8b98b3288d712cb improve readme
*   693f2c48421d9218e057340bf29de75e0d5ba8d2 Merge pull request #377 from PhrozenByte/patch-1
|\
| * 9545a295cf4cfda6e728ebf0948a12bc5530e42d README.md: Add PHP 5.3+ requirement
| * 3d649081e58c9fed5ff11aeede1be2dd2e0ee153 Update composer.json requirements
|/
*   32de2cedcc98ffb3476f5a413f47bb482691c807 Merge pull request #373 from getgrav/master
|\
| * e7443a2bd868e78946ae6a01a1b07d477ce6f4cc Fixed really sorry spelling errors
| * 10a7ff776c3f16b1b3aa41c176c48150fc091065 Left as-is
| * 5ad15b87faa2ab10f7cda7593e2e92696fafadd2 Break out method_exists checks into extendable methods to allow for better pluggability
| * b166cab9a252f4093af1f33cb178a86f6047d08a Make `lines` protected to allow for extendability
|/
* 0f974bf34fdc420c3a7dc0a6c5c5fc620fa9dd89 improve readme
* 3d7cdeec5f90a16934a2cfd35a089c78aa0e4816 remove duplicate item in: who uses it</code></pre>
<p>关于 git branch 之间的图示，有一些软件做出了不同的展示，<a href="https://pvigier.github.io/2019/05/06/commit-graph-drawing-algorithms.html">这里</a> 有一篇文章对比展示了 gitk、gitkraken、smartgit、sourcetree……多个软件的效果，并且自己也开发了 gitamine 来图示。</p>
<h2 id="分支名能否用中文">分支名能否用中文</h2>
<p>关于分支的命名，可以用一条 git 命令来检查： git check-ref-format —— 它的返回值为 0 表示 git 接受此命名，否则不接受。比如：</p>
<pre class="cmd"><code>kevin@T410:~$ git check-ref-format &quot;refs/heads/zte&quot;
kevin@T410:~$ echo $?
0
kevin@T410:~$ git check-ref-format &quot;refs/heads/z.t.e&quot;
kevin@T410:~$ echo $?
0
kevin@T410:~$ git check-ref-format &quot;refs/heads/zt..e&quot;
kevin@T410:~$ echo $?
1
kevin@T410:~$ git check-ref-format &quot;refs/heads/@zte&quot;
kevin@T410:~$ echo $?
0
kevin@T410:~$ git check-ref-format &quot;refs/heads/z~t^e&quot;
kevin@T410:~$ echo $?
1
kevin@T410:~$ git check-ref-format &quot;refs/heads/z:t?e&quot;
kevin@T410:~$ echo $?
1</code></pre>
<p>先解释一下 ref/hedas ：分支和 tag 都是指针，ref 就是指针的意思，所有 branch 和 tag 在.git/config 中都是以 ref/… 命名的，如果不加 ref ， check-ref-format 命令将不能正确识别。</p>
<p>可以发现两个点 .. 、~、^、:、? 这些都是不允许的，斜杠允许但不允许在末尾。</p>
<p>最后，来看看你最关心的中文名：</p>
<pre class="cmd"><code>kevin@T410:~$ git check-ref-format &quot;refs/heads/中兴&quot;
kevin@T410:~$ echo $?
0</code></pre>
<p>是允许的。</p>
<p>那么 branch/tag 的命名到底规则如何呢？</p>
<p>看 git 帮助即可：</p>
<pre class="cmd"><code>$ git help check-ref-format</code></pre>
<p>里面是这样解释的：</p>
<pre><code>Git imposes the following rules on how references are named:

1. They can include slash / for hierarchical (directory) grouping, but no slash-separated component can begin with a dot .  or end with the sequence .lock.
2. They must contain at least one /. This enforces the presence of a category like heads/, tags/ etc. but the actual names are not restricted. If the --allow-oneleveloption is used, this rule is waived.
3. They cannot have two consecutive dots ..  anywhere.
4. They cannot have ASCII control characters (i.e. bytes whose values are lower than \040, or \177 DEL), space, tilde ~, caret ^, or colon : anywhere.
5. They cannot have question-mark ?, asterisk *, or open bracket [ anywhere. See the --refspec-pattern option below for an exception to this rule.
6. They cannot begin or end with a slash / or contain multiple consecutive slashes (see the --normalize option below for an exception to this rule)
7. They cannot end with a dot ..
8. They cannot contain a sequence @{.
9. They cannot be the single character @.
10. They cannot contain a \.</code></pre>
<h2 id="分支太多容易分不清咋办">分支太多容易分不清咋办</h2>
<pre><code>$ vi ~/.bashrc</code></pre>
<p>增加</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb74-1" title="1"><span class="kw">function</span><span class="fu"> git-branch-prompt</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb74-2" title="2">  <span class="bu">local</span> <span class="va">branch=</span><span class="kw">`</span><span class="fu">git</span> symbolic-ref --short -q HEAD <span class="op">2&gt;</span>/dev/null<span class="kw">`</span></a>
<a class="sourceLine" id="cb74-3" title="3">  <span class="kw">if</span><span class="bu"> [</span> <span class="va">$branch</span><span class="bu"> ]</span>; <span class="kw">then</span> <span class="bu">printf</span> <span class="st">&quot; [%s]&quot;</span> <span class="va">$branch</span><span class="kw">;</span> <span class="kw">fi</span></a>
<a class="sourceLine" id="cb74-4" title="4"><span class="kw">}</span></a>
<a class="sourceLine" id="cb74-5" title="5"><span class="va">PS1=</span><span class="st">&quot;\u @ \[\033[0;36m\]\W\[\033[0m\]\[\033[0;32m\]</span><span class="dt">\$</span><span class="st">(git-branch-prompt)\[\033[0m\] </span><span class="dt">\$</span><span class="st"> &quot;</span></a></code></pre></div>
<hr />
<p>学会了分支操作（创建、合并、冲突……）是与人合作的基础，你是否已经准备好了走出个人的宇宙，拥抱开源的大世界了！</p>
<p>第 3 局，Over！</p>
<h1 id="round-4-协作">Round 4 : 协作</h1>
<p><img src="img/children-dam-bali-sw.jpg" /></p>
<h2 id="想看看别人的-git-库了">想看看别人的 git 库了</h2>
<p>是不是已经不满足于只管理个本机的日记了？太好了，git 天生就是为了程序猿合作用的，几条关键的命令要出场了：</p>
<ul>
<li><code>git clone url [localname]</code></li>
<li><code>git fetch</code></li>
<li><code>git pull</code></li>
<li><code>git push</code></li>
</ul>
<p>一幅图说明问题：</p>
<p><img src="img/git-pull-push.png" /></p>
<p>最左边的 remote 和左边 3 个（repository、index、workspace)是同等地位的，意思是 remote 是远方某人的电脑，里面其实也包含了（repository、index、workspace)中的 3 个或 2 个，大家地位是平等的。</p>
<h2 id="橡树与木棉">橡树与木棉</h2>
<p>svn 中每个人的本机是 client，数据库在 server 上，离开 server，你看不到 log，无法做 commit。但 git 没有 server 的概念，或者说 server 就在每个人的本机上，无非是保存了 repo 的哪些东东。</p>
<p>每两人之间互相分享、交换代码是通过： pull、push、fetch、clone 这几个命令来完成的，你是我的 remote，我也是你的 remote，大家彼此之间就像橡树与木棉，谁也不是攀援谁的凌霄花，谁也不是谁的痴情鸟儿，两个 remote 只是两颗近旁的橡树和木棉，根紧握在地下，叶相触在云里，仿佛永远分离，却又终身相依。</p>
<p>我可以独立的生长，我 commit 代码不必次次都跟你商量，你也是，我们之间的每次 push 和 pull 都建立的互相尊重、地位平等的前提下，你不必绑架我，我也不限制你。</p>
<h2 id="git-与-github">git 与 github</h2>
<p>这个问题就像经典的 C++与 VC 的区别，问了很多年了还是有刚出校门的同学在问，我后来一度觉得这不能怪同学们，谁叫他俩非要起这么相近的名字，让人傻傻分不清。</p>
<p>git 和 github 更加淋漓尽致的体现这个现象，也是 git 入门的必问问题之一。谁让 github 这帮小伙起了个这样的名字，人家 sourceforge、googlecode、codeplex 都不以自己所用的版本管理软件的名字来标榜自己，唯独 github，为了显摆自己用了 git，起了个 git 转发器（hub）这个名字 —— 呵呵，开玩笑了，仔细琢磨，你会发现 hub（转发器）这个词选的真是绝了，太贴切了。</p>
<p>git 和 github 我用一句话就让你理解：就像 BT 和迅雷。——类似“迅雷使用 BT 协议，增加了权限、种子列表、热门榜单等”，github 使用 git 协议，增加了权限、项目列表、热门榜单等。其他就不多解释了。</p>
<h2 id="github-与他的小伙伴们到哪里找开源项目">github 与他的小伙伴们（到哪里找开源项目）</h2>
<p>开源项目托管网站（及其开始支持 git 的时间）有：</p>
<ul>
<li><a href="http://github.com">github</a>(2008.2)</li>
<li><a href="http://sourceforge.net">sourceforge</a>(2009.3)</li>
<li><a href="http://code.google.com">Google Code</a>(2011.7) —— 2015 年底已关闭服务</li>
<li><a href="http://www.codeplex.com">CodePlex</a>(2012.3)</li>
<li><a href="http://code.csdn.net">CSDN Code</a>(2013.10)</li>
<li><a href="http://git.oschina.net">OSChina git</a>(2013)</li>
<li><a href="https://coding.net/">Coding</a></li>
</ul>
<p>这些网站之间有很多有趣的历史，也是互为竞争对手。2004 年我第一次接触开源的时候，项目经理给我的任务是到 sourceforge 下载一个叫做 rainbow 的源码，当时还没有 git，开源项目托管第一平台 sourceforge 已经独霸江湖 10 余年，它是在用 cvs，作为一个还在学校的学生，真的是摸索了很久。</p>
<p>很多年过去了，看江湖风云，开源项目版本管理系统从 cvs 到 svn，又从 svn 到 git。开源项目托管网站从 sourceforge 逐步衰败，到群众寄予厚望的 google code 风光无限，但最终都还是和其他网站一起，败在了一个 2008 年创立、2011 年才火起来的后起之秀手上，google code 也于 2015 年底宣布关闭。此后起之秀就是当下无人匹敌的：github。</p>
<p>有个有趣的小插曲：CodePlex 是微软家的，也开张好多年了，sourceforge 时代就不愠不火，反正在大家眼里微软和开源本就是水火不容、盖茨/鲍尔默和托瓦茨也是井水不犯河水。但在 2012 年微软突然做出了一个有趣的决定：</p>
<p><img src="img/codeplex.torvalds.png" /></p>
<p>近几年，微软更是几乎放弃了自家的 CodePlex，转投 github，开源自己的.NET 都在 github 上了。</p>
<p>2017 年 4 月 1 日，愚人节这天微软宣布将关闭了 codeplex，4 月 1 日开始关闭新项目的创建，10 月进入只读模式，12 月 15 彻底 over，结束 codeplex 11 年的生涯。回想当然用 C# 和 ASP.NET 的时候，经常上 codeplex 上溜达，都将随风而逝，成为回忆。</p>
<h2 id="为什么-github-成了程序员的麦加圣地">为什么 github 成了程序员的麦加圣地</h2>
<p>不解释，它就是那么酷！ – 谁用谁知道</p>
<ul>
<li><a href="http://www.xuanfengge.com/github-cheats.html">GitHub 秘籍，为你解读 Git 与 Github 酷而少知的功能</a></li>
</ul>
<h2 id="公司内如何穿过-proxy-访问-github">公司内如何穿过 Proxy 访问 github</h2>
<p>git 会使用“git confing 配置”和“shell 变量配置”两类：</p>
<embed src="img/git-proxy.svg" />
<h3 id="使用-git-config-配置">使用 git config 配置</h3>
<pre class="cmd"><code>$ git config --global http.proxy http://&lt;proxyserver&gt;:&lt;port&gt;
$ git config --global https.proxy http://&lt;proxyserver&gt;:&lt;port&gt;</code></pre>
<p>实战：</p>
<ul>
<li>没有配置 proxy 时，提示连不上 github</li>
</ul>
<pre class="cmd"><code>$ git clone https://github.com/wkevin/GitChat.git GC
Cloning into &#39;GC&#39;...
fatal: unable to access &#39;https://github.com/wkevin/GitChat.git/&#39;: Failed to connect to github.com port 443: Timed out</code></pre>
<ul>
<li>配置 proxy</li>
</ul>
<pre class="cmd"><code>$ git config --global http.proxy http://proxysz.zte.com.cn:80
$ git config --global https.proxy http://proxysz.zte.com.cn:80</code></pre>
<ul>
<li>喝了杯茶，回来再试 OK</li>
</ul>
<pre class="cmd"><code>$ git clone https://github.com/wkevin/GitChat.git GC
Cloning into &#39;GC&#39;...
remote: Counting objects: 64, done.
remote: Compressing objects: 100% (5/5), done.
remote: Total 64 (delta 0), reused 0 (delta 0), pack-reused 59
Unpacking objects: 100% (64/64), done.
Checking connectivity... done.</code></pre>
<h3 id="使用-shell-环境变量配置">使用 shell 环境变量配置</h3>
<ul>
<li>首先查看是否已经有了环境变量</li>
</ul>
<pre class="cmd"><code>$ export |grep proxy
$</code></pre>
<ul>
<li>定义环境变量</li>
</ul>
<pre class="cmd"><code>$ export http_proxy=&quot;http://proxysz.zte.com.cn:80/&quot;
$ export https_proxy=&quot;https://proxysz.zte.com.cn:80/&quot;
$</code></pre>
<ul>
<li>再次查询: OK</li>
</ul>
<pre class="cmd"><code>$ export |grep proxy
declare -x http_proxy=&quot;http://proxysz.zte.com.cn:80/&quot;
declare -x https_proxy=&quot;https://proxysz.zte.com.cn:80/&quot;
$</code></pre>
<ul>
<li>git 应该以及可以链接外网了</li>
<li>临时想连接内网（临时不用 proxy），咋办</li>
</ul>
<pre class="cmd"><code>$ export -n http_proxy  //export -n 只是标记此变量不再是环境变量，但仍然是shell变量
$ set |grep http_proxy
http_proxy=http://proxysz.zte.com.cn:80/   //set命令仍然能够查看到
$ export http_proxy     //再次export即可</code></pre>
<h2 id="定义了外网和内网两个-remoteproxy-怎么同时支持">定义了外网和内网两个 remote，proxy 怎么同时支持</h2>
<p>若你处在某个 proxy 之内，你的某个项目又有两个 remote，分别在外网和公司内网，则会遇到这样的困扰：</p>
<ul>
<li>为 git 配置了 http.proxy 后，外网 OK，内网的就连不上</li>
<li>去掉 http.proxy 后，内网的 remote OK，外网的又连不上</li>
</ul>
<p>解决这个问题有几种方法：</p>
<ol type="1">
<li>给不同的 remote 配专用的 proxy： <code>git config --local --add remote.&lt;name&gt;.proxy ""</code>
<ul>
<li>第一次 <code>git clone</code> 要麻烦一点</li>
</ul></li>
<li>一类 remote 用 http.proxy，另一类 remote 用 ssh
<ul>
<li>如果想外网的 remote 用 ssh，要给<strong>ssh 配置 proxy</strong>（<a href="http://blog.csdn.net/qq634416025/article/details/42835409">参考 1</a>、<a href="http://iyuan.iteye.com/blog/1672982">参考 2</a>）</li>
</ul></li>
<li>shell 中用<code>export http_proxy ...</code>来访问外网 remote，另开一个 shell 则无此环境变量，可用于内网 remote。</li>
</ol>
<h2 id="ssh-访问-remote-的通常步骤是啥">SSH 访问 remote 的通常步骤是啥</h2>
<p>OK，书接上文。</p>
<pre class="cmd"><code>$ ssh-keygen -t rsa -C &quot;wkevin27@gmail.com&quot;</code></pre>
<ul>
<li>生成公钥和密钥
<ul>
<li>得到两个文件：id_rsa 和 id_rsa.pub</li>
<li><strong>请确定两个文件的路径</strong>：git for windows 有时候生成的文件会位于：<code>C:\ShellHome</code>，而<code>git push</code>等命令使用的是用户根目录，这两个目录未必一致，可能会被用户无意间修改。</li>
</ul></li>
<li>拷贝公钥到 github/gitlab
<ul>
<li>可打开文件手工拷贝</li>
<li>可 <code>clip &lt; ~/.ssh/id_rsa.pub</code> 拷贝到粘贴板</li>
</ul></li>
<li>添加密钥到 ssh-agent（可选）
<ul>
<li><code>$ eval "$(ssh-agent -s)"</code></li>
<li><code>$ ssh-add ~/.ssh/id_rsa</code></li>
</ul></li>
<li>测试
<ul>
<li><code>$ ssh -T git@github.com</code></li>
</ul></li>
<li>然后就可以使用 ssh 方式访问 gitlab/github 了
<ul>
<li><code>git remote add xyz git@github.com:wkevin/GitChat.git</code></li>
<li><code>git push xyz master</code></li>
</ul></li>
</ul>
<p>各个开源项目托管网站对 ssh 的要求可能还会有些许差别，但都会在显著位置进行说明，如果如上操作后仍不能访问，请仔细查阅。</p>
<h2 id="如何与别人合作">如何与别人合作</h2>
<p>当面沟通必不可少，svn 和 git 并不能解决所有问题，每个团队都可以有自己的分支策略、日志模版、合并规则、标签原则……</p>
<h2 id="如何在-github-上与别人合作">如何在 github 上与别人合作</h2>
<p>github 的工作流： <a href="https://guides.github.com/introduction/flow/">Understanding the GitHub Flow</a></p>
<h2 id="怎样才能第一时间得知-git-上有提交和更新">怎样才能第一时间得知 git 上有提交和更新</h2>
<p>和团队成员保持紧密合作在敏捷中非常重要，SVN 的时候有一个非常优秀的软件 CommitMonitor，能够监控 SVNServer 的更新，图标是一双大眼睛，悄悄的躲在任务栏，发现更新大眼睛变成红色转啊转的。</p>
<p>git 和 svn 有所不同，svn 有 server，监控器只需要监控 server 即可，git 没有 server，只有 hub，或者说每个人电脑里的 git 都是 server，大家通过 hub 进行同步。监控 server 和监控 hub 的思路是有些差别的，各位看官可细细品味。</p>
<p>监控 git hub 的软件有：</p>
<ul>
<li>windows 平台
<ul>
<li>SourceLog：https://github.com/tomhunter-gh/SourceLog</li>
<li>SCM Notifier： https://github.com/pocorall/scm-notifier</li>
</ul></li>
<li>linux 平台
<ul>
<li>GitMon：https://github.com/spajus/gitmon</li>
<li>git-dude： https://github.com/sickill/git-dude</li>
<li>git-notifier： http://www.icir.org/robin/git-notifier</li>
</ul></li>
<li>macOS 平台
<ul>
<li>Gitifier：https://github.com/nschum/Gitifier</li>
</ul></li>
</ul>
<p>但经过我的试用，功能还都不完善，希望它们早日成熟、好用。</p>
<p>目前可以使用 github/gitlab 的 RSS Feed 功能：</p>
<p>针对个人的 RSS Feed：<br />
<img src="img/gitlab-rss-feed-user.png" /></p>
<p>针对团队的 RSS Feed：<br />
<img src="img/gitlab-rss-feed-group.png" /></p>
<p>使用 RSS Reader（图中使用的是 Snafer）订阅的效果：<br />
<img src="img/gitlab-rss-reader.png" /></p>
<h2 id="为什么说不要用-git-pull而是用-git-fetch-git-merge-代替">为什么说不要用 git pull，而是用 git fetch + git merge 代替</h2>
<p>git pull 的问题是它把过程的细节都隐藏了起来，以至于你不用去了解 git 中各种类型分支的区别和使用方法。当然，多数时候这是没问题的，但一旦代码有问题，你很难找到出错的地方。看起来 git pull 的用法会使你吃惊，简单看一下 git 的使用文档应该就能说服你。</p>
<p>将下载（fetch）和合并（merge）放到一个命令里的另外一个弊端是，你的本地工作目录在未经确认的情况下就会被远程分支更新。当然，除非你关闭所有的安全选项，否则 git pull 在你本地工作目录还不至于造成不可挽回的损失，但很多时候我们宁愿做的慢一些，也不愿意返工重来。</p>
<h2 id="如何不-clonefetch-到本地看-remote-repo-的-log">如何不 clone/fetch 到本地看 remote repo 的 log?</h2>
<h2 id="程序猿如何频繁地-commit但又低调地-push">程序猿如何频繁地 commit，但又低调地 push</h2>
<p>SVN 和 git 面对同样的一个问题：大部分程序猿是含蓄、内敛的，他既希望频繁的 commit，让 svn/git 帮他记住每一步，但并不想把这些过程信息全都公诸于众，而只是把阶段性成果推送给大家或服务器。</p>
<p>具体情况还要分为两种：假定两名程序员 A、B</p>
<ol type="1">
<li>A、B 负责的代码耦合性不高，或 A、B 不相互依赖
<ul>
<li><a href="http://codecampo.com/topics/379?comment_id=1354#comment-1354">构造干净的 Git 历史线索</a></li>
</ul></li>
<li>A、B 负责的代码耦合性高，或 A、B 相互依赖
<ul>
<li>需求：协同开发：调试期间多人之间代码依赖，相互调用，使用头文件……</li>
<li>设计：用 SVN 也可以协同开发，但会在服务器上留下大量无效的调试记录</li>
<li>操作：git 方式：<strong>将本机库开放给同伴，合作开发完成后使用 git rebase -i 清理</strong>
<ul>
<li>准备
<ul>
<li>A 君
<ul>
<li>.git 目录下新建 git-daemon-export-ok 文件，表明该工程允许非授权访问
<ul>
<li>cd /path/to/project.git</li>
<li>touch git-daemon-export-ok</li>
</ul></li>
<li><code>git daemon --reuseaddr --base-path=/opt/git/ /opt/git/</code></li>
<li>告诉 B 君你的 IP</li>
</ul></li>
<li>B 君
<ul>
<li>git checkout git://your_ip_address/project</li>
</ul></li>
</ul></li>
<li>调试过程
<ul>
<li>A 君快乐的随意本机修改并 git commit</li>
<li>B 君随时随地的 git pull</li>
</ul></li>
<li>调试完成后
<ul>
<li>A 君
<ul>
<li>git rebase -i 将本地的提交进行清理</li>
<li>将一次记录 git push 到服务器上</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<h2 id="通过-http-push-时每次都要求输入-namepassword能否避开">通过 http push 时每次都要求输入 name/password，能否避开</h2>
<ul>
<li>配置是否需要 git 认证小助手把密码存储起来</li>
</ul>
<pre class="cmd"><code>$ git config credential.helper store</code></pre>
<p>以后 <code>git push</code> 再要求输入用户名、密码后，会保存在 ~/.git-credentials 文件中。</p>
<p>或者，也可以手工创建<code>.git-credentials</code>文件，替换其中的 name 和 password:</p>
<pre class="cmd"><code>$ echo &quot;https://&lt;name&gt;:&lt;password&gt;@github.com&quot; &gt; ~/.git-credentials</code></pre>
<p>注意几点：</p>
<ol type="1">
<li>~/.git-credentials 打开可看到明文密码 ，<strong>所以，千万不要在公用电脑上配置此项。</strong></li>
<li>如果有多个 github 账号，保存/备份好 ~/.git-credentials 文件，不要搞混、搞丢失了。</li>
<li>如果你打开了<strong>两步验证</strong>，则通常意义的 password 已经不能使用，网站会提供 tocken 给你替代 password，请在 ~/.git-credentials 文件中用 tocken 替代之。</li>
</ol>
<h2 id="如何删除远程分支">如何删除远程分支</h2>
<ul>
<li>删除本地分支是： <code>git branch remove &lt;branchName&gt;</code></li>
<li>删除远程分支：
<ul>
<li><code>git push origin :&lt;branchName&gt;</code></li>
<li><code>git push origin --delete &lt;branchName&gt;</code></li>
</ul></li>
</ul>
<h2 id="如何删除远程-tag">如何删除远程 tag</h2>
<ul>
<li>删除本地 tag
<ul>
<li><code>git tag -d &lt;tagname&gt;</code></li>
</ul></li>
<li>删除远程 tag
<ul>
<li><code>git tag -d &lt;tagname&gt;</code></li>
<li><code>git push origin :refs/tags/&lt;tagname&gt;</code></li>
<li><code>git push origin --delete tag &lt;tagname&gt;</code></li>
</ul></li>
</ul>
<h2 id="别人把远程分支删除了我本地的对应分支怎么还在">别人把远程分支删除了，我本地的对应分支怎么还在</h2>
<p>张三删除了某个 branch 并 push 到 github，李四<code>git fetch/pull</code>之后该 branch 在李四本地库里是仍然存在的，如何删除之？</p>
<ol type="1">
<li><code>git fetch -p</code></li>
<li><code>git remote prune origin</code></li>
</ol>
<h2 id="维持树的整洁">维持树的整洁</h2>
<p><a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a></p>
<p>方法就是：在 git push 之前，先 git fetch，再 git rebase</p>
<p>git rebase（衍合）</p>
<p>git rebase 一般自己一个人开发时使用，用来保持提交记录的整洁。一旦上传到 github 后，不应该使用 git rebase,不然被骂死。</p>
<p>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。<br />
如果你遵循这条金科玉律，就不会出差错。否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p>
<h2 id="git-多用户间协作还有什么引人入胜之处">Git 多用户间协作还有什么引人入胜之处</h2>
<ul>
<li>集中式工作流<br />
<img src="img/workflow.onecore.png" /></li>
<li>集成管理员工作流<br />
<img src="img/workflow.manager.png" /></li>
<li>司令与副官流程（Linux）<br />
<img src="img/workflow.many.layers.png" /></li>
</ul>
<h1 id="round-5-整理">Round 5 : 整理</h1>
<p><img src="img/elephants-sand-river-sw.jpg" /></p>
<h2 id="git-从何而来">git 从何而来</h2>
<p><img src="img/Torvalds.jpg" /></p>
<p>这里有一篇 git 的创始人 Torvalds（同时也是 Linux 的创始人）的接受中国媒体的一篇访谈录：</p>
<ul>
<li><a href="http://www.wtoutiao.com/a/2287349.html">Linux 创始人 Linus Torvalds 访谈，Git 的十年之旅</a> – 如果网页链接失效，重新百度即可，Torvalds 接受类似的访谈录很多，但大多是英文的。</li>
</ul>
<h2 id="git-去往何处">git 去往何处</h2>
<p>2005 年 7 月 26 日开始，Torvalds 把 git 托付给了一位日本人：<a href="https://en.wikipedia.org/wiki/Junio_Hamano">Junio Hamano</a>。Torvalds 也说过自己一生最大的成功之一就包括把 git 托付给 Hamano。</p>
<p>Hamano 现在 google，他的 github 帐号为：<a href="https://github.com/gitster">gitster</a>，头像中抱着个大熊猫，说不定比较喜欢 China 哦。<br />
<img src="img/Hamano.jpg" /></p>
<p>git 源码的<a href="https://github.com/git/git/graphs/contributors">提交统计</a>中可以发现 Hamano 是提交最踊跃的：</p>
<p><img src="img/git-contributors.png" /></p>
<p>github 上有这样几个卓越的组织（Orgnization):</p>
<ul>
<li><a href="https://github.com/git">git</a>:目前有<a href="https://github.com/orgs/git/people">8 位成员</a>，牵头人 <a href="https://github.com/schacon">Scott Chacon</a>，他们充当管理者和传教士的角色，比较重要的贡献是：
<ul>
<li>维护 git 源码
<ul>
<li>Hamano(gitster)并没有加入到这个 Orgnization 中，而只是 fork 到自己账号下，然后 PR 到 git/git，看来 gitster 只是想当程序员，不想当管理者和传教士——大概源于日本人和中国人类似，都比较低调。</li>
</ul></li>
<li>管理和维护 <a href="http://git-scm.com">git-scm.com</a> 网站</li>
</ul></li>
<li><a href="https://github.com/progit">progit</a>:目前有<a href="https://github.com/orgs/progit/people">15 位成员</a>，牵头人 <a href="https://github.com/schacon">Scott Chacon</a> 和 <a href="https://github.com/ben">Ben Straub</a>，两人目前都供职于 github 公司，其他人多是从事翻译工作。比较重要的贡献有
<ul>
<li>写了《Pro git》这本书，此书被翻译成多种语言，被奉为经典。</li>
</ul></li>
</ul>
<h2 id="git-有哪些好的入门的资料">git 有哪些好的入门的资料</h2>
<p>读到这里是需要系统的了解、学习一下 git 的时候了，<br />
当然，我明白你说的是中文资料。</p>
<p><strong>官方 Specification</strong></p>
<ul>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/">Git Man Page</a>: 即： git help 命令的输出</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/user-manual.html">Git User Manual</a></li>
<li>Git Tutorial： <a href="https://www.kernel.org/pub/software/scm/git/docs/gittutorial.html">Part1</a> – 即 <code>man gittutorial</code>; <a href="https://www.kernel.org/pub/software/scm/git/docs/gittutorial-2.html">Part2</a> – 即 <code>man gittutorial-2</code></li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/howto/">How to</a></li>
</ul>
<p><strong>Book</strong></p>
<ul>
<li>Pro Git:根正苗红的书
<ul>
<li>第 2 版：<a href="http://git-scm.com/book/zh/v2">中文官方在线版</a>、<a href="http://www.kancloud.cn/kancloud/progit">中文国内在线版</a>、<a href="http://git-scm.com/book/en/v2">英文官方在线版</a></li>
<li>第 1 版：<a href="http://git-scm.com/book/zh/v1">中文官方在线版</a>、<a href="http://git.oschina.net/progit/">中文国内在线版</a></li>
</ul></li>
<li><a href="http://gitbook.liuhui998.com/index.html">Git Community Book 中文版</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">git 简明教程</a></li>
</ul>
<p><strong>Website</strong></p>
<ul>
<li></li>
<li><a href="http://git.wiki.kernel.org">git SCM wiki</a> – 2011 年已停止更新</li>
</ul>
<h2 id="git-命令我掌握的七七八八了怎么整理一下">git 命令我掌握的七七八八了，怎么整理一下</h2>
<p>google 或 bing 上搜索图片：<strong>git cheat sheet</strong> —— 不要在 baidu 上搜索，结果你会很失望。</p>
<p>可以看到很多热心网友们整理的常用命令集，快选一幅打印出来或作为桌面吧！</p>
<p>比如（版权归作者所有，本文仅是转发）：</p>
<p><img src="img/Git-Cheatsheet-1.png" /><br />
<img src="img/Git-Cheatsheet-3.jpg" /><br />
<img src="img/Git-Cheatsheet-4.png" /><br />
<img src="img/Git-Cheatsheet-5.png" /></p>
<p>也有一些复杂到令人发指的：<br />
<img src="img/Git-Cheatsheet-2.png" /></p>
<h2 id="重新梳理-git-的软件">重新梳理 git 的软件</h2>
<p>是时候看一下 git 的 <a href="https://en.wikipedia.org/wiki/Git_(software)">维基百科</a> 了：</p>
<blockquote>
<p>Git is a widely-used source code management system for software development. It is a distributed revision control system with an emphasis on speed,[6] data integrity,[7] and support for distributed, non-linear workflows.[8] Git was initially designed and developed in 2005 by Linux kernel developers (including Linus Torvalds) for Linux kernel development.[9]</p>
</blockquote>
<blockquote>
<p>As with most other distributed version control systems, and unlike most client–server systems, every Git working directory is a full-fledged repository with complete history and full version-tracking capabilities, independent of network access or a central server.[10] Like the Linux kernel, Git is free software distributed under the terms of the GNU General Public License version 2.</p>
</blockquote>
<ul>
<li><p>UI 前端也有，比如 github 出品的 <a href="https://desktop.github.com">github desktop</a></p></li>
<li><p><a href="https://github.com/git-for-windows/git">Git for Windows</a><br />
_ 第一代的名字叫 sysGit](https://github.com/msysgit/git)，基于 msys（属于 MinGW）—— 2015 年底已废弃<br />
_ 第二代重新建立了 github 项目<a href="https://github.com/git-for-windows/git">Git for Windows</a>，基于 msys2（不再属于 MinGW），英语有自信的可以读读它的<a href="https://github.com/git-for-windows/git/wiki">背景</a></p>
<ul>
<li><a href="http://code.google.com/p/tortoisegit/">TortoiseGit</a>：类似 TortoiseSVN，可以做图标重绘。</li>
</ul></li>
</ul>
<h2 id="整理-git-的外网托管网站">整理 git 的外网托管网站</h2>
<p>git 库的托管网站（git host）有很多，github 并不是唯一的选择，github 最困扰开发者的一点就是：它丫竟然不交钱不给创建私有库。</p>
<p>下面介绍几个其他的：</p>
<ul>
<li><a href="https://bitbucket.org">Bitbucket</a>: 流行最广的给开免费私有库的网站，可以创建无限多个私有库，充分满足了不想开源、不敢开源、和羞于开源的广大程序员们。</li>
<li><a href="http://git.oschina.net">开源中国 oschina 的 git</a>：开源中国在 2013 年创建的，号称全面、永久开放私有库，立志做中国的 github，不知道是哪一天，突然它自己改名字了，叫：码云，我勒个去。</li>
<li><a href="http://code.csdn.net">CSDN Code</a>：</li>
</ul>
<p>这里有一个表格，对比各个 git host： https://git.wiki.kernel.org/index.php/GitHosting ，关注 <strong>Free private repositories</strong>，提供免费服务的也不老少，但大部分只是提供 git 的基本托管，并没有 github 的 fork、PR、gist、gitbook……等服务。</p>
<p>如果你要开发一个开源的模块来扬名，请使用 github；如果要开发一个秘密的、需要保密的大项目，请使用 Bitbucket；如果只是玩一玩，请使用码云（毕竟速度要快一点）。</p>
<h2 id="linux-中能否使用多个版本的-git">linux 中能否使用多个版本的 git</h2>
<p>那是必须可以的。</p>
<ul>
<li>场景 1：你受限与 linux 版本太古老，无论用 yum 还是 apt 安装的都是很古老的 git</li>
<li>场景 2：你希望测试自己多个 git 的兼容性</li>
</ul>
<p>在 linux 上使用源码编译基本可以解决，步骤：</p>
<ul>
<li>在 https://git-scm.com/ 上下载最新（或自己喜欢）的源码</li>
<li><code>tar xvf git-2.9.5.tar.xz</code></li>
<li><code>cd git-2.9.5</code></li>
<li><code>./configure --prefix=/home/kevin/.local/git295</code> : 这里根据需求指定分开的目录即可</li>
<li><code>make -j8 &amp;&amp; make install</code></li>
<li><strong>风险提示：</strong>：
<ul>
<li>如果 make install 后手工挪动、重命名了 git295 目录，则执行 git 时会出现错误</li>
</ul></li>
</ul>
<h1 id="round-6-奇技淫巧">Round 6 : 奇技淫巧</h1>
<p><img src="img/resting-lions-tanzania-sw.jpg" /></p>
<h2 id="从当前库中快速导出一个节点committag另作他用">从当前库中快速导出一个节点(commit、tag)另作他用</h2>
<p>比如：</p>
<ul>
<li>导出某次提交或某个分支给他人看看，但 checkout 过去，看完再 checkout 回来是有成本的（当前工作要打断，要 commit 或 stash）</li>
<li>导出多个标签进行对比查看，比如想比较一下 v1.0、v1.1、v1.3 三个版本之间的差异，则在一个目录下通过 checkout 就搞不定了</li>
</ul>
<p>建议方案：</p>
<p><strong>方案 1</strong>： <code>git archive</code> 导出一份不受 git 管理的纯内容出去</p>
<pre class="cmd"><code>$ cd projectA.git
$ mkdir ../projectA-v1.2
$ git archive v1.2 | tar -x -C ../projectA-v1.2</code></pre>
<p><strong>方案 2</strong>：<code>git worktree</code> 在另外一处创建一个分支 —— 这是 git2.5 新增的一个功能，相当有趣</p>
<ul>
<li>原始状态：本地仅 master 分支</li>
</ul>
<pre class="cmd"><code>$ git br
* master                cf4edda [origin/master] 修订proxy的使用方法
  remotes/origin/HEAD   -&gt; origin/master
  remotes/origin/master cf4edda 修订proxy的使用方法
  remotes/zte/master    cf4edda 修订proxy的使用方法</code></pre>
<ul>
<li>首先看看现有哪些 worktree</li>
</ul>
<pre class="cmd"><code>$ git worktree list
E:/demo/GitChat.git  cf4edda aster]</code></pre>
<ul>
<li>在另外一个文件夹，用当前分支，创建一份新的工作拷贝</li>
</ul>
<pre class="cmd"><code>$ git worktree add -b 4compare ../forCompare
Preparing ../forCompare (identifier forCompare)
HEAD is now at cf4edda 修订proxy的使用方法

$ ls ../
forCompare/  GitChat.git/</code></pre>
<ul>
<li><code>git branch</code>可以查看到新创建的分支</li>
</ul>
<pre class="cmd"><code>$ git branch -vv
  4compare cf4edda 修订proxy的使用方法
* master   cf4edda [origin/master] 修订proxy的使用方法

$ git worktree list
E:/demo/GitChat.git  cf4edda aster]
E:/demo/forCompare   cf4edda [4compare]</code></pre>
<ul>
<li>进入新创建的文件夹中，可以查看到</li>
</ul>
<pre class="cmd"><code>$ cd ../forCompare/
$ git branch -vv
* 4compare cf4edda 修订proxy的使用方法
  master   cf4edda [origin/master] 修订proxy的使用方法</code></pre>
<p>OK，可以在 forCompare 目录下工作了</p>
<p>我们继续探讨一下<code>git worktree</code>的其他用法</p>
<ul>
<li><code>git worktree</code>不但可以根据某个 branch 创建，也可以从某个 tag 创建</li>
</ul>
<pre class="cmd"><code>$ git worktree add -b new2 ../new2 v0.1
Preparing ../new2 (identifier new2)
HEAD is now at 5d21d8b new file:   img/git-state-and-area.svg</code></pre>
<ul>
<li>还可以根据某个 commit 创建</li>
</ul>
<pre class="cmd"><code>$ git worktree add -b new ../new 5d21d8b
Preparing ../new (identifier new)
HEAD is now at 5d21d8b new file:   img/git-state-and-area.svg</code></pre>
<ul>
<li>删除 worktree：<code>git prune</code>能够删除目标文件已经被删除的 worktree</li>
</ul>
<pre class="cmd"><code>$ git worktree list
E:/demo/GitChat.git  cf4edda aster]
E:/demo/forCompare   cf4edda [4compare]
E:/demo/new          5d21d8b [new]
E:/demo/new1         12205fd [new1]
E:/demo/new2         5d21d8b [new2]

$ rm -rf ../new2

$ git worktree list
E:/demo/GitChat.git  cf4edda aster]
E:/demo/forCompare   cf4edda [4compare]
E:/demo/new          5d21d8b [new]
E:/demo/new1         12205fd [new1]
E:/demo/new2         5d21d8b [new2]

$ git worktree prune

$ git worktree list
E:/demo/GitChat.git  cf4edda aster]
E:/demo/forCompare   cf4edda [4compare]
E:/demo/new          5d21d8b [new]
E:/demo/new1         12205fd [new1]

$ rm -rf ../new ../new1 ../forCompare/

$ git worktree prune

$ git worktree list
E:/demo/GitChat.git  cf4edda aster]</code></pre>
<h2 id="导出某个子目录及其-log-成为一个新的-repo">导出某个子目录及其 log 成为一个新的 repo</h2>
<pre><code>cd oldrepo
git subtree split -P subdir -b newbranch
gitk newbranch

mkdir ../newrepo.git
cd ../newrepo.git
git init
git config --bool core.bare true

cd ../oldrepo
git push ../newrepo.git newbranch:master #newrepo.git is a pure repo without my files

cd ..
git clone newrepo.git</code></pre>
<h2 id="分支-2-需改-bug但我正在分支-1-上编码并不想-commit-怎么办">分支 2 需改 bug，但我正在分支 1 上编码并不想 commit 怎么办</h2>
<p>使用 git 的时候，我们往往使用 branch 解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码, 如果别人或者自己发现原有的分支上有个不得不修改的 bug，我们往往会把完成一半的代码 commit 提交到本地仓库，然后切换分支去修改 bug，改好之后再切换回来。这样的话往往 log 上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急 Bug，那么使用’git stash’就可以将你当前未提交到本地（和服务器）的代码推入到 Git 的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修 Bug，等到修完 Bug，提交到服务器上后，再使用’git stash apply’将以前一半的工作应用回来。也许有的人会说，那我可不可以多次将未提交的代码压入到栈中？答案是可以的。当你多次使用’git stash’命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑，’git stash list’命令可以将当前的 Git 栈信息打印出来，你只需要将找到对应的版本号，例如使用’git stash apply stash@{1}’就可以将你指定版本号为 stash@{1}的工作取出来，当你将所有的栈都应用回来的时候，可以使用’git stash clear’来将栈清空。</p>
<ul>
<li>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到 Git 栈中。</li>
<li>git stash pop: 从 Git 栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个 Stash 的内容，所以用栈来管理，pop 会从最近的一个 stash 中读取内容并恢复。</li>
<li>git stash list: 显示 Git 栈内的所有备份，可以利用这个列表来决定从那个地方恢复。</li>
<li>git stash clear: 清空 Git 栈。此时使用 gitg 等图形化工具会发现，原来 stash 的哪些节点都消失了。</li>
<li>git stash apply：将以前一半的工作应用回来</li>
</ul>
<h2 id="modify-错了我要丢弃本地目录中的修改">modify 错了，我要丢弃本地目录中的修改</h2>
<ul>
<li><code>git clean -df</code>：丢弃 untracked 的文件，不丢弃 modified 的文件
<ul>
<li>git clean -f: 删除 untracked files</li>
<li>git clean -fd: 连 untracked 的目录也一起删掉</li>
<li>git clean -xfd: 连 gitignore 的 untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o 之类的文件用的）</li>
<li>在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删
<ul>
<li>git clean -nxfd</li>
<li>git clean -nf</li>
<li>git clean -nfd</li>
</ul></li>
</ul></li>
<li><code>git checkout HEAD .</code>: 见下条</li>
<li><code>git reset --hard HEAD</code>: 见下条</li>
</ul>
<h2 id="add-错了我要丢弃暂存区的修改">add 错了，我要丢弃暂存区的修改</h2>
<p><strong>仅丢弃暂存区的修改，不丢弃本地目录的修改</strong></p>
<ul>
<li><code>git reset [--soft] HEAD</code>: 用 HEAD 分支覆盖一下暂存区,不影响本地文件</li>
</ul>
<p><strong>丢弃暂存区&amp;本地目录的修改</strong></p>
<ul>
<li><code>git checkout HEAD .</code> 或指定文件 <code>git checkout HEAD file</code>:用当前分支的库中文件覆盖暂存区和本地的</li>
<li><code>git reset --hard HEAD</code> 用 HEAD 覆盖一下暂存区和本地目录
<ul>
<li>git reset –hard HEAD</li>
<li>git reset –hard HEAD~1</li>
<li>git reset –hard HEAD~5</li>
</ul></li>
</ul>
<h2 id="commit-错了我要丢弃某个-commit-节点">commit 错了，我要丢弃某个 commit 节点</h2>
<ul>
<li><code>git reset commitHash~1</code>: 即可让 HEAD 指向 commitHash 前一个 commit，即：丢弃 commitHash</li>
</ul>
<p>上面这 3 个丢弃都用到了 <code>git reset</code> 命令，这是个危险的命令，没有搞懂之前一定要慎重，否则丢了就可能找不回来了。</p>
<p>理解 <code>git reset</code> 请参考下文<strong>git 原理</strong>章节中的 <strong>git reset 原理图</strong></p>
<h2 id="push-错了我要丢弃-remote-上的某个节点">push 错了，我要丢弃 remote 上的某个节点</h2>
<p>管理员： 胆子越来越大了啊，都 push 到 server 里了，还要删除，羞不羞啊 :)<br />
程序员： 给个机会吧，这几个 commit 确实不想 push 到 server 上。<br />
管理员： 有没有想过 server 上的这个分支已经被 N 多同学 fetch 过了，已经基于它做开发了，你 reset 了几个节点，别人会出错的！<br />
程序员： 不会的，这个分支只有我一个人用<br />
管理员： 哪个分支啊？<br />
程序员： master<br />
管理员： 啥？ master 分支 O_O ，你有没有看 gitlab 的帮助文档，master 分支被 gitlab 保护了，保护分支除了只允许 Master 角色有写权限外，还不允许任何人对其<code>git push --force</code>操作，也不允许任何人删除保护分支的。<br />
程序员： 有这一说？我说 <code>git push --force origin master:master</code> 咋提示我失败呢</p>
<p>十几分钟后……</p>
<p>程序员： 我研究了 gitlab 的权限说明： https://about.gitlab.com/2014/11/26/keeping-your-code-protected/ ，保护分支是可以取消保护的<br />
管理员： shit，这都被你找到了，好吧，我承认是可以，就在 project - seetings 里面，只给你这一次机会啊，快去吧。</p>
<p>终于可以霸王硬上弓了。上弓方法有三：</p>
<ol type="1">
<li><code>git reset xxx</code> 先回退本地，然后 <code>git push --force origin master:master</code></li>
<li><code>git reset --soft hashcode remoteRepo</code></li>
<li>把本地的回退了，然后把远程 branch 删掉，然后 push 新的</li>
</ol>
<h2 id="暂存一个文件的部分改动">暂存一个文件的部分改动</h2>
<p>比如说，你对一个文件进行了多次修改并且想把他们分别提交。这种情况下，你可以在添加命令(add)中加上-p 选项</p>
<p><code>git add -p [file_name]</code></p>
<p>会逐段（hunk）提示你是否 add。</p>
<h2 id="能否从不同的分支里选择某次提交并且把它合并到当前的分支">能否从不同的分支里选择某次提交并且把它合并到当前的分支</h2>
<p><code>git cherry-pick [commit_hash]</code></p>
<p>这个命令会带来冲突，请谨慎使用</p>
<h2 id="head和head是啥"><code>HEAD^</code>和<code>HEAD~</code>是啥</h2>
<p><code>^</code>和<code>~</code>是 2 个很有意思的字符，配合使用可表示祖宗十八代。任你给一个节点（HEAD 或 哈希值），都能顺藤摸瓜，找到其祖先是谁。</p>
<p>网友通常这么解释：</p>
<ul>
<li><code>^</code>：表示第几个父/母亲 ——　 git 存在多个分支合并的情况，所以不只有 1 对父母亲</li>
<li><code>~</code>：表示向上找第几代，相当于连续几个 <code>^</code></li>
</ul>
<p>比如有这样一个库：</p>
<pre><code>          b1(HEAD)
          |
C4 ------ C6
         /
   --- C5

自己: C6 = HEAD^0         = HEAD~0         = C6^0       = C6~0
父亲: C4 = HEAD^1 = HEAD^ = HEAD~1 = HEAD~ = C6^1 = C6^ = C6~1 = C6~
母亲: C5 = HEAD^2                          = C6^2
</code></pre>
<p>我经过反复琢磨，给出另外一种更形象的解释：</p>
<ul>
<li><code>^x</code>：<strong>抬头走</strong>1 步，入 x 号岔路口。</li>
<li><code>~y</code>：<strong>低头走</strong>y 步，无视岔路口。</li>
</ul>
<p>所以：<code>^^</code>: 抬头 2 步，都是 1 号口；<code>^2^</code>：抬头走 2 步，第 1 步入 2 号口；<code>^^3^</code>：抬头走 3 步，第 2 步入 3 号口；<code>~^~</code>：低头 1 步，抬头 1 步，再低头 1 步；<code>~2^~^2</code>：低头走 2 步，抬头 1 步如 1 号口，再低头 1 步，再抬头 1 步如 2 号口 …… 怎么样？用抬头走、低头走理论是不是一下就理解了？心情舒畅吧。</p>
<p>这样，我们就可以方便的得到：</p>
<pre><code>爷爷：HEAD^^    = HEAD^~    = HEAD~2
奶奶：HEAD^^2
姥爷：HEAD^2^   = HEAD^2~
姥姥：HEAD^2^2
……</code></pre>
<p><code>^</code> 和 <code>~</code> 可用于 git 的多种操作：log、diff、show、checkout……</p>
<p>实际操作一下：</p>
<pre><code>kevin@:linux.git$ git log --oneline -n20 --graph
*   c11fb13a117e (HEAD -&gt; master, tuna/master, kernel/master, github/master) Merge branch &#39;for-linus&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/hid/hid
|\
| * 3ed224e273ac HID: logitech-dj: Fix 064d:c52f receiver support
| * f9482dabfd16 Revert &quot;HID: core: Call request_module before doing device_add&quot;
| * e0b7f9bc0246 Revert &quot;HID: core: Do not call request_module() in async context&quot;
| * 15fc1b5c8612 Revert &quot;HID: Increase maximum report size allowed by hid_field_extract()&quot;
| * eb6964fa6509 HID: i2c-hid: add iBall Aer3 to descriptor override
* |   b076173a309e Merge tag &#39;selinux-pr-20190612&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux
|\ \
| * | fec6375320c6 selinux: fix a missing-check bug in selinux_sb_eat_lsm_opts()
| * |  e2e0e09758a6 | 2019-06-12 21:28:21 +0800 |  Gen Zhang  selinux: fix a missing-check bug in selinux_add_mnt_opt( )
| * |  aff7ed485168 | 2019-06-11 10:07:19 +0200 |  Ondrej Mosnacek  selinux: log raw contexts as untrusted strings
* | |    35110e38e6c5 | 2019-06-12 05:57:05 -1000 |  Linus Torvalds  Merge tag &#39;media/v5.2-2&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media
</code></pre>
<p>自己：</p>
<pre><code>kevin@:linux.git$ git log --oneline -n1 HEAD^0
c11fb13a117e (HEAD -&gt; master, tuna/master, kernel/master, github/master) Merge branch &#39;for-linus&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/hid/hid</code></pre>
<pre><code>kevin@:linux.git$ git log --oneline -n1 HEAD~0
c11fb13a117e (HEAD -&gt; master, tuna/master, kernel/master, github/master) Merge branch &#39;for-linus&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/hid/hid</code></pre>
<p>父亲：</p>
<pre><code>kevin@:linux.git$ git log --oneline -n1 HEAD^
b076173a309e Merge tag &#39;selinux-pr-20190612&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux</code></pre>
<pre><code>kevin@:linux.git$ git log --oneline -n1 HEAD^1
b076173a309e Merge tag &#39;selinux-pr-20190612&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux</code></pre>
<pre><code>kevin@:linux.git$ git log --oneline -n1 HEAD~
b076173a309e Merge tag &#39;selinux-pr-20190612&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux</code></pre>
<pre><code>kevin@:linux.git$ git log --oneline -n1 HEAD~1
b076173a309e Merge tag &#39;selinux-pr-20190612&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux</code></pre>
<p>爷爷：</p>
<pre><code>kevin@:linux.git$ git log --oneline -n1 HEAD^^
35110e38e6c5 Merge tag &#39;media/v5.2-2&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media</code></pre>
<pre><code>kevin@:linux.git$ git log --oneline -n1 HEAD^~
35110e38e6c5 Merge tag &#39;media/v5.2-2&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media</code></pre>
<pre><code>kevin@:linux.git$ git log --oneline -n1 HEAD~2
35110e38e6c5 Merge tag &#39;media/v5.2-2&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media</code></pre>
<p>奶奶</p>
<pre><code>kevin@:linux.git$ git log --oneline -n1 HEAD^^2
fec6375320c6 selinux: fix a missing-check bug in selinux_sb_eat_lsm_opts()</code></pre>
<p>母亲：</p>
<pre><code>kevin@:linux.git$ git log --oneline -n1 HEAD^2
3ed224e273ac HID: logitech-dj: Fix 064d:c52f receiver support</code></pre>
<p>姥爷：</p>
<pre><code>kevin@:linux.git$ git log --oneline -n1 HEAD^2~
f9482dabfd16 Revert &quot;HID: core: Call request_module before doing device_add&quot;</code></pre>
<p><strong>总体来说：找父亲一族要方便些，找母亲一族要麻烦些。</strong></p>
<h2 id="如何统计一段时间文件或文件夹的修改次数">如何统计一段时间文件（或文件夹）的修改次数</h2>
<p>为了快速了解代码，有时候需要快速的查看代码的统计信息，做一些宏观的把握，上面这个需求可能会有些用处。</p>
<p><strong>先来复习一下 git 自身的 统计功能</strong>：</p>
<ul>
<li><code>--stat</code>：每个文件的修改的行数，并用+-符号展示</li>
</ul>
<pre><code>kevin@:linux.git$ git diff HEAD^ --stat
 drivers/hid/hid-a4tech.c                 | 11 ++++++++---
 drivers/hid/hid-core.c                   | 16 +++-------------
 drivers/hid/i2c-hid/i2c-hid-dmi-quirks.c |  8 ++++++++
 10 files changed, 136 insertions(+), 54 deletions(-)</code></pre>
<ul>
<li><code>--numstat</code>：每个文件的修改的行数，并用数字展示</li>
</ul>
<pre><code>kevin@:linux.git$ git diff HEAD^ --numstat
8       3       drivers/hid/hid-a4tech.c
3       13      drivers/hid/hid-core.c
8       0       drivers/hid/i2c-hid/i2c-hid-dmi-quirks.c</code></pre>
<ul>
<li><code>--shortstat</code>：所有文件修改的行数汇总</li>
</ul>
<pre><code>kevin@:linux.git$ git diff HEAD^ --shortstat
 10 files changed, 136 insertions(+), 54 deletions(-)</code></pre>
<ul>
<li><code>--dirstat=[changes|lines|files]</code>：按文件夹统计和汇总下述数据
<ul>
<li>changes：变化的行数（新增文件不算）</li>
<li>lines：+和-的行数统一算（新增文件会被计算）</li>
<li>files：文件变化的数量夹</li>
</ul></li>
</ul>
<pre><code>kevin@:linux.git$ git diff HEAD^ --dirstat=changes
 100.0% drivers/hid/
kevin@:linux.git$ git diff HEAD^ --dirstat=lines
   4.2% drivers/hid/i2c-hid/
  95.7% drivers/hid/
kevin@:linux.git$ git diff HEAD^ --dirstat=files
  10.0% drivers/hid/i2c-hid/
  90.0% drivers/hid/</code></pre>
<p>另外，<code>--stat</code> 也能用于 <code>git log</code>，等价于每条 commit 都 diff 一下，即： <code>git log --stat</code> == <code>for (ci in commints) { git diff ci --stat }</code></p>
<pre><code>kevin@:linux.git$ git log --oneline --shortstat
c11fb13a117e (HEAD -&gt; master, tuna/master, kernel/master, github/master) Merge branch &#39;for-linus&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/hid/hid
b076173a309e Merge tag &#39;selinux-pr-20190612&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux
fec6375320c6 selinux: fix a missing-check bug in selinux_sb_eat_lsm_opts()
 1 file changed, 14 insertions(+), 6 deletions(-)
35110e38e6c5 Merge tag &#39;media/v5.2-2&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media
e2e0e09758a6 selinux: fix a missing-check bug in selinux_add_mnt_opt( )
 1 file changed, 14 insertions(+), 5 deletions(-)
aa7235483a83 Merge branch &#39;for-linus&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
4d8f5f91b8a6 Merge branch &#39;stable/for-linus-5.2&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/konrad/swiotlb
c23b07125f8a Merge tag &#39;vfio-v5.2-rc5&#39; of git://github.com/awilliam/linux-vfio
6fa425a26515 Merge tag &#39;for-5.2-rc4-tag&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux
aff7ed485168 selinux: log raw contexts as untrusted strings
 1 file changed, 8 insertions(+), 2 deletions(-)</code></pre>
<p>大量没有 file 修改的 merge 挺碍眼的，使用 <code>--no-merges</code> 清理</p>
<pre><code>kevin@:linux.git$ git log --oneline --shortstat --no-merges
fec6375320c6 selinux: fix a missing-check bug in selinux_sb_eat_lsm_opts()
 1 file changed, 14 insertions(+), 6 deletions(-)
e2e0e09758a6 selinux: fix a missing-check bug in selinux_add_mnt_opt( )
 1 file changed, 14 insertions(+), 5 deletions(-)
aff7ed485168 selinux: log raw contexts as untrusted strings
 1 file changed, 8 insertions(+), 2 deletions(-)</code></pre>
<p><strong>OK，基础功能展示完毕，基于这些，我们来发挥一下：</strong></p>
<ul>
<li><strong>找到目标日期之后的提交</strong>
<ul>
<li><code>--no-pager</code>：git 默认使用 linux 的 less 模式显示，即满屏后提示用户按一下按键才继续显示，加上此选项则可以一口气打印完毕</li>
<li><code>%h</code>：此处我只需要 hash 值，所以其他都省略了</li>
<li><code>--no-merges</code>: 虽然 merge 也是工作量，但和我们的统计任务无关</li>
</ul></li>
</ul>
<pre><code>kevin@:linux.git$ git --no-pager log --format=format:&#39;%h&#39; --no-merges --since 2019-06-10
fec6375320c6
e2e0e09758a6
aff7ed485168
f6581f5b5514</code></pre>
<ul>
<li><strong>找到每次提交的修改文件</strong>
<ul>
<li>awk：逐行处理上面查出的 hash 值，用 system() 命令转给 git 去执行</li>
<li><code>--stat-name-width=300</code>：git diff 的输出默认会压缩到 80 列，使用<code>...</code>这种，这样会丢失我想要的信息，所以我加大到 300，应该不会有丢弃了</li>
<li><code>--name-only</code>：我只是想统计文件的个数，并没有计划汇总每次、每个文件内部变更的行数，所以只要名字即可</li>
<li><code>"$1" "$1"~"</code>：最终会形成 <code>git diff xxx xxx~</code> ，为什么没用 <code>^</code>，效果一样么？留作思考题 ：）</li>
<li>下面代码中可以看到 hooks.c 文件在 4 次提交中被修改过 2 次</li>
</ul></li>
</ul>
<pre><code>kevin@:linux.git$ git --no-pager log --format=format:&#39;%h&#39; --no-merges --since 2019-06-10 | \
awk &#39;{system(&quot; git --no-pager diff  --stat-name-width=300 --name-only &quot;$1&quot; &quot;$1&quot;~&quot;) }&#39;
security/selinux/hooks.c
security/selinux/hooks.c
security/selinux/avc.c
kernel/cred.c
kernel/ptrace.c</code></pre>
<ul>
<li><strong>统计并数字显示</strong>
<ul>
<li><code>fs[$0]+=1</code>: 用文件名做 key，value 每次+1</li>
</ul></li>
</ul>
<pre><code>kevin@:linux.git$ git --no-pager log --format=format:&#39;%h&#39; --no-merges --since 2019-06-10 | \
awk &#39;{system(&quot; git --no-pager diff  --stat-name-width=300 --name-only &quot;$1&quot; &quot;$1&quot;~&quot;) }&#39;| \
awk &#39;{fs[$0]+=1} END{for(f in fs) printf(&quot;%d\t%s\r\n&quot;,fs[f],f) }&#39; | sort -k 2
1   kernel/cred.c
1   kernel/ptrace.c
1   security/selinux/avc.c
2   security/selinux/hooks.c</code></pre>
<ul>
<li><strong>还可以统计到某一层文件夹，而不是具体到每个文件</strong>
<ul>
<li><code>-e 's/[^/]*$//'</code>：去掉文件名，只留路径</li>
<li><code>-e 's#/#|#1'</code>：精确匹配第 1 个<code>/</code>更换成<code>|</code>，这里的 1 可以自己修改，统计不同 level 的文件夹深度</li>
<li><code>-e 's/|.*//'</code>：把<code>|</code>以后的字符删除 —— 这样只留下我们想要的某个 level 深度的路径</li>
</ul></li>
</ul>
<pre><code>kevin@:linux.git$ git --no-pager log --format=format:&#39;%h&#39; --no-merges --since 2019-06-1 | \
awk &#39;{system(&quot; git --no-pager diff  --stat-name-width=300 --name-only &quot;$1&quot; &quot;$1&quot;~&quot;) }&#39;| \
sed -e &#39;s/[^/]*$//&#39; -e &#39;s#/#|#1&#39; -e &#39;s/|.*//&#39; | \
awk &#39;{fs[$0]+=1} END{for(f in fs) printf(&quot;%10d\t%s\r\n&quot;,fs[f],f) }&#39;|sort -k 2
       676  arch
         9  block
        10  crypto
         2  Documentation
      2027  drivers
       128  fs
       286  include
         2  ipc
        43  kernel
        21  lib
        16  mm
       103  net
         9  samples
        17  scripts
        93  security
       304  sound
       114  tools
         5  virt</code></pre>
<p>上面是 6.1 至今（6.14），半个月来 Linux 的修改，仍然是 drivers 中的文件最多，达到 2027 件次（类比“人次”这个单位，哈哈），kernel 前几天已经发布 5.1 了，其实 kernel 半个月才更新了 43 个件次，还是超级稳定的。</p>
<p>BTW：上面思考题的答案：用<code>^</code> 和 <code>~</code> 是一样的。</p>
<h1 id="round-7-原理拾趣">Round 7 : 原理拾趣</h1>
<p><img src="img/black-trevally-sardines-sw.jpg" /></p>
<h2 id="git-和-svn-在元数据存储上有什么区别">git 和 SVN 在元数据存储上有什么区别</h2>
<p>svn 是基于增量存储的，两次提交对于 repo 来说只保存变化量，git 不使用 svn 的增量方式保存数据，而是使用快照。因为 git 的分布式特性，并没有一颗树一样成长的 repo，repo 更像是一张网式的成长，节点与节点之间可能会绕很远才能找到亲戚关系，所以增量无从谈起。</p>
<p>来看下面这个过程：</p>
<ul>
<li>A、B 两个 git clone</li>
<li>A 的 commit 时间比 B 晚</li>
<li>A 先 push</li>
<li>B 在 push 时失败，先 pull，再次 commit</li>
<li>A 一次 ci，B 两次 ci —— 比 svn 多了一次 ci，因为 svn 中 B 是先 merge 后 ci，git 中是先 ci 后 merge 再 ci</li>
<li>B 再 push</li>
<li>git log：ci 的顺序是：B 的 ci、A 的 ci、B 的 merge 后 ci —— <strong>B 的 ci 会插入到 A 的 ci 前面</strong></li>
</ul>
<p>如果用增量存储，将很难把整个过程记录下来，根本原因是：<strong>开发者提交前是不需要同步别人代码的</strong>。</p>
<h2 id="git-的对象object">git 的对象（object）</h2>
<p><a href="http://gitbook.liuhui998.com/1_2.html">GIT 对象模型</a></p>
<ul>
<li>git 的指针（branch 是指针）指向某个对象（object）</li>
<li>git 的 object 包含 4 个部分：
<ul>
<li>对象名：40bit 的 HASH</li>
<li>类型：有 4 种：
<ol type="1">
<li>blob</li>
<li>tree</li>
<li>commit</li>
<li>tag</li>
</ol></li>
<li>大小：</li>
<li>内容：</li>
</ul></li>
<li>可以使用 <code>git show &lt;对象名&gt;</code> 来查看一个 object 的内容</li>
</ul>
<p>4 类 object 的图示：</p>
<table>
<thead>
<tr class="header">
<th>blob</th>
<th>tree</th>
<th>commit</th>
<th>tag</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><img src="img/object-blob.png" /></td>
<td><img src="img/object-tree.png" /></td>
<td><img src="img/object-commit.png" /></td>
<td><img src="img/object-tag.png" /></td>
</tr>
</tbody>
</table>
<p>我的粗浅认识是：</p>
<ul>
<li>blob 对象封装了具体的文件，<a href="http://baike.baidu.com/link?url=uwTulBgFwwZkFIksfXQHzCFT1Nrm1U7Eo_3LY-1uZJwl6JYrDETOitmBdJeYKVwVOCLwUnF_0RozRyPHDTvSKK">blob 的百度百科</a>，blob 单词的意思是一疙瘩、一坨。</li>
<li>tree 类似目录、文件夹，包含了 tree 和 blob</li>
<li>commit：包含了一个 tree 的指针（对象名），和父级 commit 对象，还有<code>git commit</code>时的相关信息。</li>
<li>tag：指向一个 commit 对象</li>
</ul>
<p>来实际操作一把：</p>
<ul>
<li><code>git log</code> 找一条 commit</li>
</ul>
<pre class="cmd"><code>$ git lg
 e3426a5 | 2016-02-16 11:20:22 +0800 | 2016-02-16 11:20:22 +0800 |  Kevin Wang  调整章节，内容基本没变
 a15f695 | 2016-02-16 10:28:16 +0800 | 2016-02-16 10:28:16 +0800 |  Kevin Wang  增加 git cheat sheet 小节
 c242093 | 2016-02-04 11:30:21 +0800 | 2016-02-04 11:30:21 +0800 |  wkevin  笔误
 48eda25 | 2016-02-04 11:21:57 +0800 | 2016-02-04 11:21:57 +0800 |  wkevin  笔误: 缺少一个反括号</code></pre>
<ul>
<li><code>git show &lt;object-name&gt;</code> 可以查看各类 object 的细节</li>
<li><code>git show &lt;commit-object-name&gt;</code> 可以查看 commit 类型的细节，其中包括了 diff（即：和 parrent 父级 commit 对象相比的差异：tree 及其 blob 的差异）</li>
</ul>
<pre class="cmd"><code>$ git show  e3426a5
commit e3426a51534d97f5c73369a98fd38d6fb2f83f0a
Author: Kevin Wang &lt;wkevin27@gmail.com&gt;
Date:   Tue Feb 16 11:20:22 2016 +0800

    调整章节，内容基本没变

diff --git a/README.md b/README.md
index 17944e2..a0be055 100644
--- a/README.md
+++ b/README.md
@@ -31,21 +31,24 @@ git 有自己的 [user manunal](https://www.kernel.org/pub/software/scm/git/docs
     - erge是怎么玩儿的](#merge)
 - [Round 4](#round4)</code></pre>
<ul>
<li><code>git show --pretty=raw &lt;commit-object-name&gt;</code> 还能更多的查看 commit 对象所指向的 tree 对象</li>
</ul>
<pre class="cmd"><code>$ git show --pretty=raw e3426a5
commit e3426a51534d97f5c73369a98fd38d6fb2f83f0a
tree 65e1673d28da6cf7554cc0bed020673f68276112
parent a15f6954d609da2bebc243a52a8dd1094e6e2fd6
author Kevin Wang &lt;wkevin27@gmail.com&gt; 1455592822 +0800
committer Kevin Wang &lt;wkevin27@gmail.com&gt; 1455592822 +0800

    调整章节，内容基本没变

diff --git a/README.md b/README.md
index 17944e2..a0be055 100644
--- a/README.md
+++ b/README.md</code></pre>
<ul>
<li><code>git show &lt;tree-object-name&gt;</code> 或 <code>git ls-tree &lt;tree-object-name&gt;</code> 或 <code>git ls-tree &lt;commit-object-name&gt;</code> 都能够看到 tree 对象更多的细节</li>
</ul>
<pre class="cmd"><code>$ git show 65e1673
tree 65e1673

.gitignore
README.md
img/

$ git ls-tree 65e1673
100644 blob 40f51b88ea8b90ff1c9db36ffc45cfd71f71c078    .gitignore
100644 blob a0be0555eeeb50e4702e137a7837ad9970be7755    README.md
040000 tree 5aec0814a9b43d040a1a3388aaf2c4ae60e296f4    img

$ git ls-tree e3426a5
100644 blob 40f51b88ea8b90ff1c9db36ffc45cfd71f71c078    .gitignore
100644 blob a0be0555eeeb50e4702e137a7837ad9970be7755    README.md
040000 tree 5aec0814a9b43d040a1a3388aaf2c4ae60e296f4    img</code></pre>
<ul>
<li><code>git show &lt;blob-object-name&gt;</code> 查看一个 blob 对象的细节，如果是文本文件就等同于<code>$cat file</code>了</li>
</ul>
<pre class="cmd"><code>$ git show 40f51b
*.html
.vim.*</code></pre>
<h2 id="git-的快照存储有点不可思议如何做到好又多的">git 的快照存储有点不可思议，如何做到好又多的</h2>
<ul>
<li>继续前面的话题，我们往前查几个 commit 对象，试图发现的更多一些</li>
</ul>
<pre class="cmd"><code>$ git show --pretty=raw 48eda25
commit 48eda255c3f727e57f1462592a8cd8fd8d16839a
tree f1683d3e377fcbb99cca10c481d0070375e1bf23
parent 12205fd2616a0af5ebe8243f6e5c16a64e9e9127
author wkevin &lt;wkevin@users.noreply.github.com&gt; 1454556117 +0800
committer wkevin &lt;wkevin@users.noreply.github.com&gt; 1454556117 +0800

    笔误: 缺少一个反括号</code></pre>
<ul>
<li>看看这个 tree 对象包含的内容</li>
</ul>
<pre class="cmd"><code>$ git ls-tree f1683d3e
100644 blob 40f51b88ea8b90ff1c9db36ffc45cfd71f71c078    .gitignore
100644 blob 5211c0dae2ab042cf0cf2edff08809af510e358a    README.md
040000 tree 4867a64660a9d90a8a5a966c9fac1187861762f3    img</code></pre>
<p>可以发现两次 commit 所指向的 tree 对象中：</p>
<ul>
<li>.gitignore 的 HASH 相同</li>
<li>README.md 的 HASH 不同</li>
</ul>
<p>因此说明：<strong>每次提交仅会把有改动的 file 重新计算 HASH 并封装为对象进行存储</strong></p>
<ul>
<li>整个文件存储那不是很浪费空间？—— Yes！</li>
<li>那为什么还比 svn 的增量存储更快呢？ —— 这个问题要这么看：
<ul>
<li><code>svn commit</code>的时候是提交到网络服务器的，存在网络时延的问题，<code>git commit</code>只有本地操作</li>
<li><code>svn commit</code>的时候要实时计算 diff，<code>git add/commit</code>不存在 diff 计算，<code>git add</code>时会做对象的生成，但 git 对象的生成是执行压缩算法 —— 执行 diff 计算和执行压缩算法在当前水平的 CPU 能力下已不分伯仲</li>
<li>git 虽然耗损更多的磁盘空间，但现在最不值钱的就是磁盘空间了</li>
</ul></li>
</ul>
<h2 id="git-addcommit-原理图">git add/commit 原理图</h2>
<embed src="img/git-add.svg" type="image/svg+xml" />
<h2 id="git-checkout-原理图">git checkout 原理图</h2>
<embed src="img/git-checkout.svg" type="image/svg+xml" />
<ul>
<li><code>git checkout file</code>：用暂存区的 file 覆盖工作区的 file</li>
<li><code>git checkout branch</code>：HEAD 指向 branch，然后去覆盖暂存区和工作区</li>
<li><code>git checkout --detach branch</code>：游离指向 branch，然后去覆盖暂存区和工作区</li>
<li><code>git checkout commithash</code>：游离指针指向某次 commit，，然后去覆盖暂存区和工作区</li>
<li><code>git checkout branch/commithash file</code>：拿指针指向的 file 去覆盖暂存区和工作区的 file，所以暂存区会有待提交内容</li>
</ul>
<p>详细：</p>
<ul>
<li><code>git checkout &lt;./file&gt;</code>
<ul>
<li>HEAD 不会切换</li>
<li>用暂存区的 file 覆盖工作区中对应的文件，暂存区的不变
<ul>
<li><strong>如果没有未提交的修改，暂存区和 HEAD 是相同的</strong></li>
<li>如果暂存区刚才有未提交的修改，后续仍可 commit</li>
</ul></li>
<li>覆盖：意味着所有修改会丢失；但新增的文件不丢失。</li>
</ul></li>
<li><code>git checkout &lt;branch&gt;</code>
<ul>
<li>HEAD 会被切换</li>
<li>用 <branch> 中的文件覆盖工作区中对应的文件</li>
<li>切换的当前 branch 时：本地修改不会丢失，也不必提交</li>
<li>切换的其他 branch 时：本地修改要先提交，-f 强切修改会丢失</li>
</ul></li>
<li><code>git checkout --detach [&lt;branch&gt;]</code>
<ul>
<li>HEAD 不变
<ul>
<li><code>git checkout --detach</code>：会从当前 HEAD 创建游离指针</li>
<li><code>git checkout --detach anotherBranch</code>：会从 anotherBranch 指针创建游离指针</li>
</ul></li>
<li>从<branch>处创建一个<strong>游离</strong>的 branch，并覆盖到本地工作区</li>
<li>从当前 branch 创建游离分支时：本地修改不会丢失，也不必提交</li>
<li>从其他 branch 创建游离分支时：本地修改要先提交，-f 强切修改会丢失</li>
</ul></li>
<li><code>git checkout [--detach] &lt;commit&gt;</code>
<ul>
<li>游离一个 branch</li>
</ul></li>
<li><code>git checkout [[-b|-B|--orphan] &lt;new_branch&gt;] [&lt;start_point&gt;]</code></li>
</ul>
<h2 id="git-fetchpull-原理图">git fetch/pull 原理图</h2>
<embed src="img/git-remote.svg" type="image/svg+xml" />
<h2 id="git-reset-原理图">git reset 原理图</h2>
<embed src="img/git-reset.svg" type="image/svg+xml" />
<p><code>git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…</code><br />
<code>git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…]</code><br />
<code>git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;]</code></p>
<ul>
<li>图中 3 个动作：
<ol type="1">
<li>替换引用的指向。引用指向新的提交 ID。</li>
<li>替换暂存区。替换后，暂存区的内容和引用指向的目录树一致。</li>
<li>替换工作区。替换后，工作区的内容变得和暂存区一致，也和 HEAD 所指向的目录树内容相同。</li>
</ol></li>
<li>3 个参数：
<ul>
<li>–hard: 执行上图中的全部动作 1、2、3</li>
<li>–soft: 执行上图中的全部动作 1</li>
<li>–mixed:执行上图中的全部动作 1、2，—— 默认操作</li>
</ul></li>
<li>举例：
<ul>
<li><code>git reset</code>==<code>git reset HEAD</code>：用 HEAD 重置暂存区，工作区不受影响，相当于回滚/撤销 <code>git add</code></li>
<li><code>git reset -- filename</code> == <code>git reset HEAD filename</code>：仅将文件的改动撤出暂存区，暂存区中其他文件不改变。</li>
<li><code>git reset --soft HEAD^</code>：工作区和暂存区不改变，但是 HEAD 和当前分支引用向前回退一次
<ul>
<li>用途：提交了之后，你又发现代码没有提交完整，或者你想重新编辑一下再提交</li>
</ul></li>
<li><code>git reset --hard</code> == <code>git reset --hard HEAD</code>: 用 HEAD 覆盖暂存区和工作区，即：丢弃所有本地修改</li>
</ul></li>
<li>重置可以朝前，也可以朝后</li>
</ul>
<pre class="cmd"><code>$ git br
* master ecfc106 2
  new    ab3fa01 3
$ git reset --soft new
$ git br
* master ab3fa01 3
  new    ab3fa01 3</code></pre>
<h1 id="round-8-git-与-phabricator">Round 8 : git 与 phabricator</h1>
<h2 id="arc-为何物">arc 为何物</h2>
<ul>
<li>arc 全称是 arcanist，百度给出的中文翻译是：巧匠。</li>
<li>arc 是 Facebook 的 Phabricator 系统中用户端的命令行工具，配合 pha 提交变更评审的。</li>
<li>arc 的安装还有点折腾，要先在本机安装 PHP，和一个 php 的工具集：libphutil
<ul>
<li>windows 的安装后，目录下包括下面 3 个主要部件：</li>
</ul>
<pre><code>Phabricator/--arc/--arcanist
            |     |-libphutil
            |-xampplite-win32-1.7.3</code></pre>
<pre><code>  + arcantist是arc的主程序：https://github.com/phacility/arcanist.git
  + libphutil是php的工具集：https://github.com/phacility/libphutil.git
  + xampplite是apache+php+mysql+perl的一个打包，160+M，要知道phabricator整个才180+M。</code></pre></li>
<li>arc 包含很多子命令，
<ul>
<li><code>arc help</code>：列出来子命令看看</li>
<li><code>arc diff</code>：调用<code>svn diff</code>或<code>git diff</code>生成差异并发送给 phabricator 生成评审单</li>
<li><code>arc list</code>：列出当前 peding 的 revision —— revision 要说明一下：pha 生产的每个评审单都对应一个 revision，可以理解为 svn/git 的一次提交，但又不在用户的 svn/git 上体现，可以理解为 pha 上也驻留这一个 svn/git，来存储评审单信息，每单对应一个 revision。</li>
<li><code>arc patch</code>：将 pha 上的 revision 变更 patch 到本地工作拷贝上</li>
<li><code>arc amend</code>：更新 git commit 的 message，即：可以把 pha 上某个 revision 的 message 应用到本地 git 的某个 commit 上</li>
<li><code>arc commit</code>：svn 专用，pha 上评审完毕后，将本地的变更做<code>svn commit</code></li>
<li><code>arc land</code>：git 专用，pha 上评审完毕后，将本地分支做<code>git push</code>，所以需要有 origin</li>
<li><code>arc lint</code>：静态代码分析，不要以为 arc 只是生成评审单的，它还内嵌了一堆的 lint 工具，python 的、java 的、js 的……五花八门，在 <code>Phabricator\arc\arcanist\src\lint\linter\__tests__</code> 这个目录下列出了这些 lint 工具</li>
<li><code>arc unit</code>：执行单元测试，这个就需要用户自己来指定单元测试工具了</li>
<li><code>arc close-revision</code>：使用 arc 关闭某个 revision，而不必上 pha 上鼠标点点点啦</li>
<li>…… 还有 n 多，不一一列举了，头晕</li>
</ul></li>
<li>arc 的 configuration
<ul>
<li>和 git 类似，git 有<code>git config --[global/system/local] xxx ...</code>，arc 也有<code>arc set-config --[user/local] xxx ...</code></li>
<li>和 git 类似，git 查看 config 有<code>git config -l</code>，arc 也有<code>arc get-config</code></li>
</ul></li>
</ul>
<h2 id="arc-的安装和配置">arc 的安装和配置</h2>
<p><strong>Windows 下的安装</strong><br />
略</p>
<p><strong>Ubuntu 下的安装</strong></p>
<ul>
<li>安装
<ul>
<li><code>sudo apt-get install php5 php5-curl</code></li>
<li><code>cd somewhere</code> //arc 的安装目录</li>
<li><code>git clone https://github.com/phacility/libphutil.git</code></li>
<li><code>git clone https://github.com/phacility/arcanist.git</code></li>
<li><code>sudo ln -s arcanist/bin/arc /usr/local/bin/arc</code></li>
<li><code>vi ~/.bashrc</code>
<ul>
<li><code>source $somewhere/arcanist/resources/shell/bash-completion</code></li>
</ul></li>
</ul></li>
<li>配置
<ul>
<li><code>arc set-config $pha-server</code> //eg: <code>arc set-config http://pha.etz.com.cn</code></li>
<li><code>arc install-certificate</code>
<ul>
<li>到 $pha-server 上查找帮助，找到 tocken，填到这里</li>
<li>注意 proxy 的屏蔽</li>
</ul></li>
</ul></li>
</ul>
<h2 id="arc-diff-初步">arc diff 初步</h2>
<ul>
<li>SVN 中，<code>arc diff</code>会把未提交的本地工作拷贝中的变更生成评审单，执行<code>arc diff</code>之前不需要也不能执行<code>svn commit</code>，最终评审完，用<code>arc commit</code>来代替<code>svn commit</code></li>
<li>git 中则完全不一样，<code>arc diff &lt;startCommit&gt;</code>之前需要首先<code>git add</code>&amp;<code>git commit</code>，<strong>如果本地工作拷贝中有变更，arc diff 会自动替你 add 和 commit</strong>，因为<code>arc diff</code>是把 git 中两个 commit 之间（即：一个 range）的变更提交到 pha 上生成评审单，所以问题来了：两个 commit 节点是如何指定的？
<ul>
<li><strong>两个 commit 节点是：startCommit 和 HEAD</strong></li>
<li>startCommit 如果缺失，则默认使用 <code>git merge-base origin/master HEAD</code>
<ul>
<li>这又是个啥东东？<code>git help merge-base</code>，意思是找到 origin/master 和 HEAD 之间的最近祖先节点。</li>
<li><code>git help merge-base</code>中有几个例子，其中一个是：</li>
</ul>
<pre><code>     o---o---o---B
    /
---o---1---o---o---o---A</code></pre>
<pre><code>  * `git merge-base A B `将返回节点1，好好体会一下，呵呵。</code></pre>
<ul>
<li>所以为了不出乱子，最好自己指定 startCommit</li>
</ul></li>
</ul></li>
<li><code>arc diff</code>需要填写一些信息，所以执行过程中会跳入到一个编辑器中，windows 版的 arc 会打开一个简陋的窗口，ubuntu 版的 arc 就直接打开默认的编辑器（如 vi）了。需要填写的信息有：
<ul>
<li>Test Plan - 必填，详细说明你的测试计划；</li>
<li>Reviewers - 必填，审查人的账户，多个使用“,”隔开；
<ul>
<li>在 ubuntu 下，用 vi 编辑此信息时，不会自动不全人名，则需要到 phabricator 网站上的搜索窗口，找到需要的人，把 TA 的账号写在此处</li>
</ul></li>
<li>Subscribers - 非必填订阅人，多个使用“,”隔开。</li>
</ul></li>
</ul>
<p>实战一下：</p>
<ul>
<li>创建一个 temp 的 git repo</li>
</ul>
<pre><code>10036143@A20939270 MINGW32 /f/temp (master)
$ git log
*  75c616b | 2016-06-08 15:55:19 +0800 |  wkevin  hah
*  7584e84 | 2016-06-08 15:55:01 +0800 |  wkevin  create</code></pre>
<ul>
<li><code>arc diff</code>
<ul>
<li>会提示错误，没有指定 origin/master，因为默认 startComiit 是<code>git merge-base origin/master HEAD</code>嘛</li>
</ul></li>
<li><code>arc diff 7584</code>
<ul>
<li>可以创建评审单的，因为是拿 HEAD（即 75c6）与 7584 比较</li>
<li><code>git show HEAD</code> 可以查看 HEAD 指向哪个节点</li>
</ul></li>
<li><code>arc diff 7584 --preview</code>
<ul>
<li>可以在 pha 上创建评审单，但跳过指定评委等步骤，单子已经在 pha 上有了，可以先看看，后续在 pha 上慢慢指定评委等</li>
<li>这是专门给处女座准备的啊</li>
</ul></li>
<li>有一点需要说明：
<ul>
<li><code>arc diff</code>会根据工作拷贝的相关信息（比如 path, branch name, local commit hashes, and local tree hashes）来自动创建和关联一个 pha 上的 revision，这让一些掌控欲比较强的人可能有些恼火，可以手工指定
<ul>
<li><code>arc diff --create &lt;startCommit&gt;</code>:在 pha 上创建一个新的 revision</li>
<li><code>arc diff --update Dxxxx &lt;startCommit&gt;</code>：在 pha 上一个已有的 revision（编号 Dxxxx）上做增量</li>
</ul></li>
</ul></li>
</ul>
<h2 id="arc-diff-为什么把我已有的-commit-log-修改了">arc diff 为什么把我已有的 commit log 修改了</h2>
<p>在上面的步骤中有一个奇怪的地方：执行完<code>arc diff xxxx</code>后，<strong>原有的 HEAD 节点被 arc 重新创建的一个节点所替代</strong></p>
<ul>
<li>执行<code>arc diff 7584</code>后，75c6 被替代为了 26c0</li>
</ul>
<pre><code>$ git l
*  26c0efc | 2016-06-08 15:55:19 +0800 |  wkevin  hah
*  7584e84 | 2016-06-08 15:55:01 +0800 |  wkevin  create</code></pre>
<ul>
<li>再次执行<code>arc diff 7584</code>后，26c0 被替代为了 e6db</li>
</ul>
<pre><code>$ git l
*  e6db93c | 2016-06-08 15:55:19 +0800 |  wkevin  hah
*  7584e84 | 2016-06-08 15:55:01 +0800 |  wkevin  create</code></pre>
<ul>
<li>再次执行<code>arc diff 7584</code>后，e6db 被替代为了 7c29</li>
</ul>
<pre><code>$ git l
*  7c29204 | 2016-06-08 15:55:19 +0800 |  wkevin  hah
*  7584e84 | 2016-06-08 15:55:01 +0800 |  wkevin  create</code></pre>
<ul>
<li>但其实 75c6、26c0、e6db 都还是存在的，<code>git show</code>可以看到</li>
</ul>
<pre><code>$ git show 75c6
commit 75c616b3a6de15e7004c231486a91e338ae023a6
Author: wkevin &lt;wkevin27@gmail.com&gt;
Date:   Wed Jun 8 15:55:19 2016 +0800

    hah</code></pre>
<p>事情变得很蹊跷，arc 为什么要新建一个 commit 呢？</p>
<p>下面再来验证一下：如果本地有 modified（待 add）或 stagging（待 commit）文件的话，<code>arc diff</code>是不是也会新建一个 commit 呢？</p>
<ul>
<li>当前状态</li>
</ul>
<pre><code>$ git l
*  1cce5be | 2016-06-08 16:05:27 +0800 |  wkevin  neww
*  7c29204 | 2016-06-08 15:55:19 +0800 |  wkevin  hah
*  7584e84 | 2016-06-08 15:55:01 +0800 |  wkevin  create</code></pre>
<ul>
<li>做一些有本地修改，但不 <code>git commit -a</code></li>
<li><code>arc diff HEAD^</code>，会首先把未提交的变更进行提交，并且更新（amend）当前 commit 的 message，然后向已有的 revision 进行 update</li>
</ul>
<pre><code>$ arc diff HEAD^
You have uncommitted changes in this working copy.

  Working copy: F:\temp\

  Unstaged changes in working copy:
    README.md

    Do you want to amend this change to the current commit? [y/N] y

Linting...
No lint engine configured for this project.
Running unit tests...
No unit test engine is configured for this project.
SKIP STAGING Unable to determine repository for this change.
Updated an existing Differential revision:
        Revision URI: http://pha.zte.com.cn/D30449

Included changes:
  M       README.md</code></pre>
<ul>
<li>1cce5be 又被 20ae4c5 替代了，而不是在 1cce5be 的基础上新建一个 commit</li>
</ul>
<pre><code>$ git l
*  20ae4c5 | 2016-06-08 16:05:27 +0800 |  wkevin  neww
*  7c29204 | 2016-06-08 15:55:19 +0800 |  wkevin  hah
*  7584e84 | 2016-06-08 15:55:01 +0800 |  wkevin  create</code></pre>
<p>为了解开这个谜团，我们来跟踪一下<code>arc diff</code>的操作</p>
<p><code>arc diff --trace &lt;startCommit&gt;</code></p>
<p>摘录一部分打印：</p>
<pre><code>&gt;&gt;&gt; [1] &lt;http&gt; http://pha.zte.com.cn/api/user.whoami
&gt;&gt;&gt; [2] &lt;exec&gt; $ git diff --no-ext-diff --no-textconv --raw &#39;HEAD&#39; --
&gt;&gt;&gt; [3] &lt;exec&gt; $ git ls-files --others --exclude-standard
&gt;&gt;&gt; [4] &lt;exec&gt; $ git diff-files --name-only
&gt;&gt;&gt; [6] &lt;exec&gt; $ git rev-parse &#39;HEAD&#39;
&gt;&gt;&gt; [7] &lt;exec&gt; $ git merge-base &#39;f8c1&#39; &#39;d6efce6e8804ecb027762e0151ed071bc7d63b6d&#39;
&gt;&gt;&gt; [8] &lt;exec&gt; $ git log --first-parent --format=medium &#39;f8c101daaf75121dd4f1f1380b4dc5c1ed85cea0&#39;..&#39;d6efce6e8804ecb027762e0151ed071bc7d63b6d&#39;</code></pre>
<p>首先到 phabricator 服务器上验证 tocken，并根据 startCommit 做出一些判断</p>
<pre><code>&gt;&gt;&gt; [16] &lt;event&gt; diff.willBuildMessage &lt;listeners = 0&gt;
&gt;&gt;&gt; [17] &lt;conduit&gt; differential.getcommitmessage() &lt;bytes = 295&gt;
&gt;&gt;&gt; [18] &lt;http&gt; http://pha.zte.com.cn/api/differential.getcommitmessage
&gt;&gt;&gt; [19] &lt;exec&gt; $ git symbolic-ref --quiet HEAD
&gt;&gt;&gt; [20] &lt;exec&gt; $ which &#39;editor&#39;
&gt;&gt;&gt; [21] &lt;exec&gt; $ editor  &#39;/tmp/edit.cjol8q3bi1sg0kwk/new-commit&#39;</code></pre>
<p>然后到 phabricator 服务器上创建一个单，并根据 pha 的请求，打开 editor，编辑评审单的信息</p>
<pre><code>&gt;&gt;&gt; [22] &lt;exec&gt; $ git commit --amend --allow-empty -F &#39;/tmp/8qihi3x4l2ww4o8w/10039-Vbjrxm&#39;</code></pre>
<p>关键是这里了，无条件的更新了当前 HEAD 节点的 message。</p>
<p>其实 <code>git commit --amend</code> 的官方 help 中是这样解释的： Replace the tip of the current branch by creating a new commit.</p>
<p>这样<code>arc diff &lt;startCommit&gt;</code>步骤就明朗了：</p>
<ol type="1">
<li>提示用户填写评审单信息（Test Plans、Reviewers、Subscribers……），然后使用这些信息 <code>git commit --amend</code> 到当前分支的 HEAD 节点</li>
<li>新的节点（即：新的 HEAD） 成为 endCommit</li>
<li>再拿 HEAD（即 endCommit）与 startCommit 执行 <code>git diff</code>，输出的内容提交到 pha</li>
</ol>
<p>arc 为什么要这么做？为什么要“玷污”我的现有节点？如果这个节点是其他分支的基础节点怎么办？…… —— 这个事情可以这么看：<code>arc diff</code>只是新建了一个 commit，用来存储评审单的相关信息，并且把当前分支的 HEAD 指向了新建的 commit，想好了这一点，事情其实很好办，下一节我们来规避它。</p>
<h2 id="如何避免-arc-diff-玷污现有节点">如何避免 arc diff 玷污现有节点</h2>
<p>创建专用于评审的分支</p>
<ul>
<li><code>git branch review</code></li>
<li><code>git checkout review</code></li>
<li><code>arc diff &lt;xxx&gt;</code> 或 <code>arc diff --preview &lt;xxx&gt;</code> //创建评审单或预审单（到 pha 网站上进行下一步的操作，可用于 ubuntu 下不能自动补全人名的环境）</li>
<li><code>git checkout master</code></li>
<li><code>git branch -D review</code> //评审单一旦创建，review 分支就没有存在的必要性了</li>
</ul>
<h2 id="如何创建只包含部分文件的评审单">如何创建只包含部分文件的评审单</h2>
<p>可能只希望评审方案文件（假设： design.md），但 commit 中包含相关的图片、svg、等文件，不需要提交到 pha，如下处理：</p>
<ul>
<li><code>git branch review &lt;oneOldCommit&gt;</code> //从 design.md 创建或修改前的节点创建一个分支</li>
<li><code>git checkout review</code></li>
<li><code>git checkout master design.md</code> //将 master 分支上的 design.md check 到 review 分支</li>
<li><code>git commit -am "review for design.md"</code></li>
<li><code>arc diff HEAD^</code> 或 <code>arc diff --preview HEAD^</code></li>
<li><code>git checkout master</code></li>
<li><code>git branch -D review</code></li>
</ul>
<hr />
<p><strong>跋</strong></p>
<p>本文本来只是我个人使用 git 多年来的学习笔记和备忘录，2015 年底陆续有一些项目上的要求同事朋友们开始使用 git，我当然乐于答疑释惑。和大家互动了之后，发现直接拿笔记给别人看是不妥当的，因为笔记从头到尾没有难度梯度，大家更希望我分享的是一篇由简入难的文章。—— 听取用户需求，重新编排文章，并且查漏补缺……终于在 2016 年春节假期中成文。</p>
<ul>
<li>感谢中国的高铁，给了我从深圳到宁波的 8+小时没有网络、没有打扰的书写时间，又在节后给了我 8+小时从宁波回深圳的时间，本文骨架基本在这 16+小时中完成。</li>
<li>感谢岳父和家里的好酒，白天喝酒打牌，晚上笔耕时并不上头、反胃。但文中也会屡见突兀的行文，大概就是喝过量时候写就的了。</li>
<li>感谢 markdown 和 git，让我沉浸写作、畅快 diff、任性提交，如果使用 word，我猜是绝对写不出来的。</li>
<li>感谢问我 git 问题的同事朋友，灵感都源于你们。</li>
</ul>
        </div>
      </div>
    </div>
    
    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="assets/js/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="assets/js/jquery.min.js"><\/script>')</script>
    <script src="assets/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="assets/js/ie10-viewport-bug-workaround.js"></script>
    <script>
        //document.getElementById('sidebar').getElementsByTagName('ul')[0].className += "nav nav-sidebar";
        
        /* ajust the height when click the toc
           the code is from https://github.com/twbs/bootstrap/issues/1768
        */
        var shiftWindow = function() { scrollBy(0, -50) };
        window.addEventListener("hashchange", shiftWindow);
        function load() { if (window.location.hash) shiftWindow(); }
    </script>

  </body>
</html>
